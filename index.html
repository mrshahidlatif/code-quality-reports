<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8">
    <script src="lib/jquery-2.2.2.min.js"></script>
    <script src="lib/jquery.sparkline.js"></script>
    <script type="text/javascript" src="lib/prism.js"></script>
    <script type="text/javascript" src="js/jquery.sparkline.min.js"></script>
    <script type="text/javascript" src="js/mysparklines.js"></script>
    <script type="text/javascript" src="js/dictionary.js"></script>
    <script src="lib//jquery-ui.js"></script>
    <script src="lib/d3.min.js"></script>
    <script src="lib/d3.parcoords.js"></script>
    <script src="lib/bboxCollide.js"></script>
    <script src="lib/d3-annotation.js"></script>
    <script type="text/javascript" src="js/scatterplot.js"></script>
    
    <link rel="stylesheet" type="text/css" href="css/d3.parcoords.css">
    <link rel="stylesheet" href="lib/jquery-ui.css">
    <link rel='stylesheet' href='css/mysparklines.css' type='text/css' media='all' />
    <link rel='stylesheet' href='css/main.css' type='text/css' media='all' />
    <link href="lib/prism.css" rel="stylesheet" />
  </header>

<!-- <div class="heading">
    <input id="file-upload" type="file" value="Upload" onchange="handleFileSelect(event)"/>
    <div id="title" style="margin-top:0px;">Code Quality Documents </div>
    <div id="subtitle" style="margin-top:0px;"></div>
</div> -->

<body>
  <div id="grid-container">
    <div id="header">
      <input id="file-upload" type="file" value="Upload" onchange="handleFileSelect(event)"/>
      <div id="title">Code Quality Documents </div>
      <div id="subtitle"></div>
    </div>
    <div id="textPanel">
      <div id="textAPanel"></div>
      <div id="textBPanel"></div>
    </div>
    <div id="vis">
        <div id= "parallelplot">
          <div id="example_container">
            <div id="example" class="parcoords"></div>
          </div> 
        </div>
        <div id="scatterplot">
            <div id="controls" ></div>
            <div id="chart_container">
                <div id="chart"></div>
                <div id="tooltip" class="tooltip"></div>
            </div>
        </div>
        <div id="captionPP"></div>
        <div id="captionSP"></div>
    </div>  
    <div id="details">
      <h3 id="detailsHeader"></h3>
      <div id="detailsContent"></div>
    </div>
  </div>
</body>

<script type="text/javascript">

var projectName = "";
var fullData;
var badClasses;
var classFullNameToIndex = {}; // dictionary to retrieve idicies by class name efficiently
var classShortNameToIndex = {} // equivalent dictionary with short class names -- TODO: temporary solution, should be removed
function clone(obj) {
	if (obj === null || typeof(obj) !== 'object' || 'isActiveClone' in obj)
		return obj;

	if (obj instanceof Date)
		var temp = new obj.constructor(); //or new Date(obj);
	else
		var temp = obj.constructor();

	for (var key in obj) {
		if (Object.prototype.hasOwnProperty.call(obj, key)) {
			obj['isActiveClone'] = null;
			temp[key] = clone(obj[key]);
			delete obj['isActiveClone'];
		}
	}
	return temp;
}

var linkedSLopts = null;    //added
function handleFileSelect(event) {
	// Check for the various File API support.
	if (window.File && window.FileReader && window.FileList && window.Blob) {
		// Great success! All the File APIs are supported.
	} else {
		alert('The File APIs are not fully supported in this browser.');
	}

	$(".text").css({visibility: "hidden"});

	var f = event.target.files[0]; // FileList object
	projectName = f.name.replace('.csv','');
	var reader = new FileReader();
	reader.onload = function(event) {
		setTimeout(function(){
      d3.csv(event.target.result, function(data) {
        generateReport(data);
      });
		}, 2000);
	};

  document.getElementById("subtitle").innerHTML = projectName;
	// Read in the file as a data URL.
	reader.readAsDataURL(f);
	//modified
	linkedSLopts = {
                  csvurl: encodeURI("csv/"+f.name),
                  slids: ['samplsl2', 'samplsl1', 'samplsl3', 'samplsl4'],     //pass ids for containers of first and second graph, dafaults to ['sl1', 'sl2']
                  sldef: ['wmc,max_cc', 'cbo,ca,ce', 'lcom,lcom3', 'dit,noc'], //pass fields for graphs, defaults to ['cbo,ca,ce', 'wmc,max_cc']
                  slopts: [
                            {height: 25}, //pass Sparklines options, dafaults to {type: 'bar', disableHiddenCheck: true, height: 200, barWidth: 4}
                            //pass options specfic to each sl if required, in order
                            {stackedBarColor: ['#2b8cbe','#7bccc4']},
                            {stackedBarColor: ['#238b45','#66c2a4','#b2e2e2']},
                            {stackedBarColor: ['#c51b8a','#fa9fb5']},
                            {stackedBarColor: ['#88419d','#8c96c6']},
                          ],
                  //HLclass: 'hl',                       //pass class used to high  //function to run on success, null by defaultlight linked bar, defaults to 'hl'
                  fn_wrapup: function() {   //function to run on success, null by default
                                      $(".content").hide();
                                      $("#textPanel").css({visibility: "visible"});
                                     }
                 }
  //end of modified

}

function generateReport(data){

  //making data available to all files
  fullData = data;
	data.forEach(function(d, i){
		d.index = i;
		d.smells = {
			blob: false,
			decomposition: false,
			spaghetti: false,
      highblob : false,
      lazy: false,
		};

		var LOC = d["LOC"] || d["loc"],
			AMC = d["AMC"] || d["amc"],
			WMC = d["WMC"] || d["wmc"],
			NPM = d["NPM"] || d["npm"];

		if(LOC >= 1500 && AMC >= 129){
			d.smells.blob = true;
		}

    if(LOC >= 8000 && AMC >= 129){
			d.smells.highblob = true;
		}

		if(NPM <= 8 && WMC >= 16){
			d.smells.decomposition = true;
		}

		if(AMC >= 151){
			d.smells.spaghetti = true;
		}

    if(WMC == 0){
      d.smells.lazy = true;
    }
	});

	var html = "", badCt = 0, bugCt = 0, goodCouplingCt = 0, regularCouplingCt = 0, badCouplingCt = 0, goodInheritanceCt = 0, regularInheritanceCt = 0, badInheritanceCt = 0, goodCohesionCt = 0, regularCohesionCt = 0, badCohesionCt = 0, goodComplexityCt = 0, regularComplexityCt = 0, badComplexityCt = 0, bugBlobCt = 0, bugDecomCt = 0, blobDecomCt = 0, blobSpaCt = 0, blobLazyCt = 0, superSmellsCt = 0, goodCouplingPercent = 0, regularCouplingPercent = 0, badCouplingPercent = 0, goodInheritancePercent = 0, regularInheritancePercent =0, badInheritancePercent = 0, goodCohesionPercent = 0, regularCohesionPercent = 0, badCohesionPercent = 0, goodComplexityPercent = 0, regularComplexityPercent = 0, badComplexityPercent = 0, classCt = data.length, blobCt = 0, blobList = "", bugList = "", blobArr = [], bugArr = [], goodCouplingArr = [], regularCouplingArr = [], badCouplingArr = [], goodComplexityArr = [], regularComplexityArr = [], badComplexityArr = [], goodInheritanceArr = [], regularInheritanceArr = [], badInheritanceArr = [], goodCohesionArr = [], regularCohesionArr = [], badCohesionArr = [], bugBlobArr = [], bugDecomArr = [], blobDecomArr = [], blobSpaArr = [], blobLazyArr = [], superSmellsArr = [], goodCouplingList = "", regularCouplingList = "", badCouplingList = "",  goodInheritanceList = "", regularInheritanceList = "", badInheritanceList = "", goodCohesionList = "", regularCohesionList = "",  badCohesionList = "", goodComplexityList = "", regularComplexityList = "", badComplexityList = "", bugBlobList = "", bugDecomList = "", blobDecomList = "", blobSpaList = "", blobLazyList = "", superSmellsList = "", decomCt = 0, decomList = "", decomArr = [], spaCt = 0, spaList = "", spaArr = [], highblobCt = 0, highblobList = "", highblobArr = [], lazyCt = 0, lazyList = "", lazyArr = [], blobTag = false, decomTag = false, projInfo = "", numberOfPackages = 0, classesWithBadSmells = [], bugSpaArr = [], bugLazyArr = [], bugSpaList = "", bugLazyList = "", bugSpaCt = 0, bugLazyCt = 0, spaTag = false, lazyTag = false;

	data.forEach(function(d, i){
    classFullNameToIndex[d.cname] = i; 
    classShortNameToIndex[d.cname.split(".").pop()] = i;
    var s = d.smells;
    var badClass = new Object;
    var badSmellsinClass = [];

    var bad = false;
    
    var classSpan = createClassSpan(d.cname);

    // TODO: remove code clones in the following

		if(s.blob){
			blobCt++;
      blobArr.push(classSpan);
      bad = true;

      badSmellsinClass.push("God Class");
		}

    if(s.highblob){
      highblobCt++;
      highblobArr.push(classSpan);
      //bad = true;


    }

		if(s.decomposition){
      decomCt++;
      decomArr.push(classSpan);
			bad = true;
      badSmellsinClass.push("Functional Decomposition");
		}

		if(s.spaghetti){
      spaCt++;
      spaArr.push(classSpan);
      bad = true;

      badSmellsinClass.push("Spaghetti Code");
		}

    if(s.lazy){
      lazyCt++;
      lazyArr.push(classSpan);
      badSmellsinClass.push("Lazy Class");
    }

    if(d.bug >= 1){

      bugCt++;
      bugArr.push(classSpan);
    }

		if(bad){
			badCt++;
    }
    if (s.lazy || s.spaghetti || s.decomposition || s.blob || d.bug > 0){
      badClass.name =  d.cname.split(".").pop();
      badClass.badSmells = badSmellsinClass;
      badClass.bug = d.bug;
      classesWithBadSmells.push(badClass);
    }
    badClasses = classesWithBadSmells;
    // console.log(classesWithBadSmells);
    //check for good coupling
    if(d.cbo <= 6 && (d.ca <= 7 || d.ce <=6)){
      goodCouplingCt++;
      goodCouplingArr.push(classSpan);
    }
    //check for regular coupling
    if((d.cbo >= 7 && d.cbo < 39) && ((d.ca > 7 && d.ca <=39) || (d.ce > 6 && d.ce <=16))){
      regularCouplingCt++;
     regularCouplingArr.push(classSpan);
   }
   //check for bad coupling
   if((d.cbo >= 9) && ((d.ca > 39) || (d.ce > 16))){
     badCouplingCt++;
     badCouplingArr.push(classSpan);
    }
  //check for good inheritance
   if(d.dit <= 2 && d.noc <= 1){
     goodInheritanceCt++;
    goodInheritanceArr.push(classSpan);
   }
   //check for regular inheritance
   if((d.dit > 2 && d.dit <= 4) && (d.noc > 1 && d.noc <= 3)){
     regularInheritanceCt++;
    regularInheritanceArr.push(classSpan);
   }
   //check for bad inheritance
   if(d.dit > 4 && d.noc > 3){
     badInheritanceCt++;
    badInheritanceArr.push(classSpan);
   }
   //check for good cohesion
   if(d.lcom3 <= 0.167){
     goodCohesionCt++;
     goodCohesionArr.push(classSpan);
   }
   //check for regular cohesion
   if(d.lcom3 > 0.167 && d.lcom3 <= 0.725 ){
     regularCohesionCt++;
     regularCohesionArr.push(classSpan);
   }
   //check for bad cohesion
   if(d.lcom3 > 0.725){
     badCohesionCt++;
     badCohesionArr.push(classSpan);
   }
   //check for good Complexity
   if(d.max_cc <= 2 || d.wmc <= 11){
     goodComplexityCt++;
     goodComplexityArr.push(classSpan);
   }
   //check for regular Complexity
   if((d.max_cc > 2 && d.max_cc <= 4) || (d.wmc > 11 && d.wmc <= 34)){
     regularComplexityCt++;
     regularComplexityArr.push(classSpan);
   }
   //check for bad Complexity
   if(d.max_cc > 4 || d.wmc > 34){
     badComplexityCt++;
     badComplexityArr.push(classSpan);
   }
  })

  //classes with coupling metrics values
  goodCouplingPercent = Math.round((goodCouplingCt/classCt)*100);
  regularCouplingPercent = Math.round((regularCouplingCt/classCt)*100);
  badCouplingPercent = Math.round((badCouplingCt/classCt)*100);

 //classes with inheritance metrics values
  goodInheritancePercent = Math.round((goodInheritanceCt/classCt)*100);
  regularInheritancePercent = Math.round((regularInheritanceCt/classCt)*100);
  badInheritancePercent = Math.round((badInheritanceCt/classCt)*100);

//classes with cohesion metrics values
  goodCohesionPercent = Math.round((goodCohesionCt/classCt)*100);
  regularCohesionPercent = Math.round((regularCohesionCt/classCt)*100);
  badCohesionPercent =  Math.round((badCohesionCt/classCt)*100);


//classes with complexity metrics values
  goodComplexityPercent = Math.round((goodComplexityCt/classCt)*100);
  regularComplexityPercent = Math.round((regularComplexityCt/classCt)*100);
  badComplexityPercent = Math.round((badComplexityCt/classCt)*100);
//counting the total bad smells



  for(var i = 0; i < bugArr.length; i++){
    var b = bugArr[i];
    if(i == 0){
      bugList += b;
    }else if(i == bugArr.length-1){
      bugList += " and "+b;
    }else{
      bugList += ", "+b;
    }
  }

	for(var i = 0; i < blobArr.length; i++){
		var b = blobArr[i];
		if(i == 0){
			blobList += b;
		}else if(i == blobArr.length-1){
			blobList += " and "+b;
		}else{
			blobList += ", "+b;
		}
	}

  for(var i = 0; i < highblobArr.length; i++){
		var b = highblobArr[i];
		if(i == 0){
			highblobList += b;
		}else if(i == highblobArr.length-1){
			highblobList += " and "+b;
		}else{
			highblobList += ", "+b;
		}
	}

	for(var i = 0; i < decomArr.length; i++){
		var b = decomArr[i];
		if(i == 0){
			decomList += b;
		}else if(i == decomArr.length-1){
			decomList += " and "+b;
		}else{
			decomList += ", "+b;
		}
	}

	for(var i = 0; i < spaArr.length; i++){
		var b = spaArr[i];
		if(i == 0){
			spaList += b;
		}else if(i == spaArr.length-1){
			spaList += " and "+b;
		}else{
			spaList += ", "+b;
		}
	}

  for(var i = 0; i < lazyArr.length; i++){
		var b = lazyArr[i];
		if(i == 0){
			lazyList += b;
		}else if(i == lazyArr.length-1){
			lazyList += " and "+b;
		}else{
			lazyList += ", "+b;
		}
	}

  for(var i = 0; i < goodCouplingArr.length; i++){
    var b = goodCouplingArr[i];
    if(i == 0){
      goodCouplingList += b;
    }else if(i == goodCouplingArr.length-1){
      goodCouplingList += " and "+b;
    }else{
      goodCouplingList += ", "+b;
    }
  }


  //check for classes having both bad smells and bugs
  var m = 0, n = 0;
  for(var i = 0; i < bugArr.length; i++){
    var str1 = bugArr[i].split('<i>').pop().split('</i>')[0];
    if(blobList.includes(str1) === true)
      {
        bugBlobArr[m] = bugArr[i];
        m++;
        bugBlobList+= str1 + " ";

        bugBlobCt+=1;
        blobTag = true;
      }
    if(decomList.includes(str1) === true)
      {
        bugDecomArr[n] = bugArr[i];
        n++;
        bugDecomList+= str1 + " ";
        bugDecomCt+=1;
        decomTag = true;
      }
      if(spaList.includes(str1) === true)
      {
        bugSpaArr[m] = spaArr[i];
        m++;
        bugSpaList+= str1 + " ";

        bugSpaCt+=1;
        spaTag = true;
      }
    if(lazyList.includes(str1) === true)
      {
        bugLazyArr[n] = bugArr[i];
        n++;
        bugLazyList+= str1 + " ";
        bugLazyCt+=1;
        lazyTag = true;
      }
  }

  //check for classes having multiple bad smells
  var j = 0, k = 0, l = 0;
  for(var i = 0; i < blobArr.length; i++){
    var str1 = blobArr[i].split('<i>').pop().split('</i>')[0];
    if(decomList.includes(str1) === true)
      {
        blobDecomArr[j] = blobArr[i];
        superSmellsArr[i] = blobDecomArr[j];
        j++;
        blobDecomList+= str1 + " ";
        blobDecomCt+=1;
        superSmellsCt+=1;
    }
    if(spaList.includes(str1) === true)
      {
        blobSpaArr[k] = blobArr[i];
        superSmellsArr[i] = blobSpaArr[k];
        k++;
        blobSpaList+= str1 + " ";
        blobSpaCt+=1;
        superSmellsCt+=1;
    }
    if(lazyList.includes(str1) === true)
      {
        blobLazyArr[l] = blobArr[i];
        superSmellsArr[i] = blobLazyArr[l];
        l++;
        blobLazyList+= str1 + " ";
        blobLazyCt+=1;
        superSmellsCt+=1;
    }
  }

  superSmellsList = blobDecomList + blobSpaList + blobLazyList;
  superSmellsList = superSmellsList.split(/[ ,]+/).join(', ');
  superSmellsList = superSmellsList.replace(/,\s*$/, "");

  badCt = blobCt + decomCt + spaCt + lazyCt;

  var paths = [];
  data.forEach(function(d, i){
    paths.push(d.cname);
  });
  paths = paths.map(function(path){return path.split('.');});

  var result = stringify(structurize(paths));
  var packages = [];
  for (var i=0; i<paths.length;i++){
    if(packages.includes(paths[i][paths[i].length-2])){
    }
    else{
    packages.push(paths[i][paths[i].length-2]);
    }
  }
  numberOfPackages = packages.length;
  result = stringify(structurize(paths)).join("\n");
  // console.log(result);

/* ------------------------------------------------------------------------*/
/* Text Generation */ 
/* ------------------------------------------------------------------------*/
  //Generate report text
  $("#textAPanel").html(badSmellsText());
  $("#subtitle").html(introText());
  html += generalQualityText();
  html += bugText();
  $("#captionPP").html(generatePPCaption());
  $("#captionSP").html(generateSPCaption());
  

  function introText(){
    var text = "";
    if(projectName.includes("xerces")) {
    projInfo = "A collection of software libraries for parsing, validating, serializing, and manipulating XML";
    }

    if(projectName.includes("log4j")) {
    projInfo =  "An open source project that allows the developer to control which log statements are output with arbitrary granularity.";
    }
    text += ' This document presents the code quality aspects of '+ projectName +'<span class="projInfo infoIcon"title=""> &#9432;</span> (Java version)&mdash;it has '+ numberOfPackages + ' packages and '+classCt+' classes.';
    return text;
  }

  function generalQualityText(){
    var text = '';
    // TODO: expand details (bar chart) when clicking on the metrics
    // TODO: Make the first sentence adaptive (should summarize the analysis somehow.)
    text+='<h3>Software Metrics</h3><p>We analyze the code quality of the project accroding to four groups of software metrics.</p>'
      
    text += generateComplexityText();
    text += generateCouplingText();
    text += generateCohesionText();
    text += generateInheritanceText();
 
    return text;
  }

  function generateCouplingText(){
    var text = '<p>';
    var coup = '<h4><span class="couplingMetric clickable">Coupling</span>:</h4>';
    // coupling quality
    var couplingArr = [goodCouplingPercent, regularCouplingPercent, badCouplingPercent];
    var m = Math.max(...couplingArr);
    var i  = couplingArr.indexOf(m);

    if(i == 0){
      text+= coup + ' The quality in terms of coupling is high because GOODCOUPLINGCT classes <span id="bar_5" class="barSpan"></span> have coupling metrics in a good range';
    }

    else if(i == 1){
      text+= coup + ' The quality in terms of coupling is moderate because REGULARCOUPLINGCT classes <span id="bar_6" class="barSpan">have coupling metrics in an acceptable range'
    }

    else if(i == 2){
      text+= coup + ' The quality in terms of coupling is low because BADCOUPLINGCT classes <span id="bar_7" class="barSpan"></span> have coupling metrics in an undersired range'
    }
    text += '<span class="couplingInfo infoIcon"title=""> &#9432;</span>. <button class="collapsible"></button><div class="content"><div id="samplsl1"></div></div></p>';
    return text;

  }
  function generateComplexityText(){
    var comp = '<h4><span class="complexityMetric clickable">Complexity</span>:</h4>';
    // complextiy quality
    var complexityArr = [goodComplexityPercent, regularComplexityPercent, badComplexityPercent];
    m = Math.max(...complexityArr);
    i  = complexityArr.indexOf(m);
    var text = '<p>';
    if(i == 0){
      text+= comp + ' The quality from complexity perspective is high because GOODCOMPLEXITYCT classes <span id="bar_14" class="barSpan"></span> have low complexity'
    }
    else if(i == 1){
      text+= comp + ' The quality from complexity perspective is medium because REGULARCOMPLEXITYCT classes <span id="bar_15" class="barSpan"></span> have regular complexity'
    }
    else if(i == 2){
      text+= comp + ' The quality from complexity perspective is low because BADCOMPLEXITYCT classes <span id="bar_16" class="barSpan"></span> have  high complexity'
    }
    return text += '<span class="complexityInfo infoIcon"title=""> &#9432;</span>. <button class="collapsible"></button><div class="content"><div id="samplsl2"></div></div></p>';

  }
  function generateCohesionText(){
    var coh = '<h4><span class="cohesionMetric clickable">Cohesion</span>:</h4>';

    var cohesionArr = [goodCohesionPercent, regularCohesionPercent, badCohesionPercent];
    m = Math.max(...cohesionArr);
    i  = cohesionArr.indexOf(m);
    var text = '<p>';
    if(i == 0){
      text+= coh + ' High values of cohesion metrics in GOODCOHESIONCT classes <span id="bar_11" class="barSpan"></span> reflect good project quality';
    }
    else if(i == 1){
      text+= coh + ' Moderate values of cohesion metrics in REGULARCOHESIONCT classes <span id="bar_12" class="barSpan"></span> reflect regular quality';
    }
    else if(i == 2){
      text+= coh + ' Low values of cohesion metrics in BADCOHESIONCT classes <span id="bar_13" class="barSpan"></span> reflect bad proejct quality';
    }
    return  text += '<span class="cohesionInfo infoIcon"title=""> &#9432;</span>. <button class="collapsible"></button><div class="content"><div id="samplsl3"></div></div><p>';

  }
  function generateInheritanceText(){

    var inher = '<h4><span class="inheritanceMetric clickable">Inheritance</span>:</h4>';
     // inheritance quality
    var inheritanceArr = [goodInheritancePercent, regularInheritancePercent, badInheritancePercent];
    m = Math.max(...inheritanceArr);
    i  = inheritanceArr.indexOf(m);
    var text='<p>';
    if(i == 0){
      text += inher + ' Inheritance metrics indicate high quality in GOODINHERITANCECT classes <span id="bar_8" class="barSpan"></span>';
    }
    else if(i == 1){
      text += inher + ' Inheritance metrics indicate acceptable quality in REGULARINHERITANCECT classes <span id="bar_9" class="barSpan"></span>';
    }
    else if(i == 2){
      text += inher + ' Inheritance metrics indicate low quality in BADINHERITANCECT classes <span id="bar_10" class="barSpan"></span>';
    }

    return text += '<span class="inheritanceInfo infoIcon"title=""> &#9432;</span>. <button class="collapsible"></button><div class="content"><div id="samplsl4"></div></div></p>';

  }

  function noOfBadSmells(list){
    for(var i=0;i<list.length;i++){
      if(list[i].badSmells.length == 4)
        return list[i];
    else if (list[i].badSmells.length == 3)
      return list[i];
    else if (list[i].badSmells.length == 2)
      return list[i];
    }
  }

  // TODO: eliminate interfaces from analysis (throw them out entirely)
  // TODO: info icon after "analysis of software metrics"
  // TODO: reorder list of bad smells based on their frequency
  // TODO: mention the number of classes affected by smells, not just the number of smells
  function badSmellsText(){
    var text = "";
    text += '<h3>Code Smells</h3><div class="p">Based on an analysis of software metrics, we have ';
    if(badCt == 0){
      text+= 'not detected any class-level code smells in the project&mdash;congratulations, the quality is high.'
    } else if(badCt == 1){	
      text += 'detected one class-level code smell: ';
    } else if(badCt > 1){	
      text += 'detected '+ num2word(badCt) + ' class-level code smells, among them ';
    }
    var listOfBadSmellTypes=[];
    if(blobCt > 0){
      listOfBadSmellTypes.push(((blobCt===1)?'one':num2word(blobCt)) +' <span class="smellBlob clickable">God Class'+((blobCt===1)?'':'es')+'</span> <span class="barSpan" id="barBlob"></span> '+createCollapsibleClassList(blobArr));
    }
    if(decomCt > 0){
      listOfBadSmellTypes.push(((decomCt===1)?'one case':num2word(decomCt)+' cases') +' of <span class="smellFc clickable">Functional Decomposition</span> <span class="barSpan" id="barFc"></span> '+createCollapsibleClassList(decomArr));
    }
    if(spaCt > 0){
      listOfBadSmellTypes.push(((spaCt===1)?'one case':num2word(spaCt)+' cases') +' of <span class="smellSpa clickable">Spaghetti Code</span> <span class="barSpan" id="barSpa"></span> '+createCollapsibleClassList(spaArr));
    }
    if(lazyCt > 0){
      listOfBadSmellTypes.push(((lazyCt===1)?'one':num2word(lazyCt)) +' <span class="smellLazy clickable">Lazy Class'+((lazyCt===1)?'':'es')+'</span> <span class="barSpan" id="barLazy"></span> '+createCollapsibleClassList(lazyArr));
    }
    text += ' ' + printList(listOfBadSmellTypes) + '.';
    if(superSmellsCt > 0){
      text+= ' Some classes <button class="collapsible"></button><div class="content">' + printList(superSmellsArr) + '</div> carry multiple smells.'
    }
    var c = noOfBadSmells(classesWithBadSmells);
    if (c != undefined){ 
      text += ' For instance, '+createClassSpan(c.name)+' has ' + num2word(c.badSmells.length) + ' smells: ' + printList(c.badSmells) + '.'; 
    }
    if(highblobArr.length == 1){
      text += ' Comparatively high metric value of lines of code (loc) indicates bad quality in '+ highblobArr[0] + 
      '.';
    }
    if(highblobArr.length > 1){
      text += ' Comparatively high metric value of lines of code (loc) indicates bad quality in '+ printList(highblobArr)+ '.';
    }
    text += '</div>';
    return text;
  }

function countClassesHavingBadSmells (data){
  var count = 0;
  for (var i=0;i<data.length;i++){
    if (data[i].badSmells.length != 0){
        count++;
    }
  }
  return count;
}

function generatePPCaption(){
  // TODO: color metric names
  var caption = 'The overview of the software quality in terms of <span class="complexityMetric clickable">complexity</span> (<span class="wmc">wmc</span>, <span class="max_cc">max_cc</span>), <span class="couplingMetric clickable">coupling</span> (<span class="cbo">cbo</span>, <span class="ca">ca</span>, <span class="ce">ce</span>), <span class="cohesionMetric clickable">cohesion</span> (<span class="lcom">lcom</span>, <span class="lcom3">lcom3</span>), and <span class="inheritanceMetric clickable">inheritance</span> (<span class="noc">noc</span>, <span class="dit">dit</span>).';
  caption += ' The ' + num2word(countClassesHavingBadSmells(classesWithBadSmells)) +' <span class="BSLegend">Classes</span> contain bad smells';

  caption += '. ';

  return caption;
}
function generateSPCaption(){
  // Assuming X and Y are the selected dimensions in the scatterplot
  return 'Correlation between X and Y. ';
}

//bugs report
function NoOfBugSmells(list){
    for(var i=0; i<list.length; i++){
      if(list[i].badSmells.length == 4 && list[i].bug != "0")
        return list[i];
    else if (list[i].badSmells.length == 3 && list[i].bug != "0")
      return list[i];
    else if (list[i].badSmells.length == 2 && list[i].bug != "0")
      return list[i];
    }
  }

  function classesWithBugSmells(list){
    var c = [];
    for(var i=0; i<list.length; i++){
      if(list[i].badSmells.length == 4 && list[i].bug != "0")
        c.push(list[i].name);
    else if (list[i].badSmells.length == 3 && list[i].bug != "0")
      c.push(list[i].name);
    else if (list[i].badSmells.length == 2 && list[i].bug != "0")
      c.push(list[i].name);
    }
    return c;
  }


function bugText(){
  var text = "";
  text += '<h3>Bug History</h3>'
  if(bugCt/classCt == 0){
    text =+ 'None of the classes was associated with recorded bugs.'
  }
  else{
    var c = NoOfBugSmells(classesWithBadSmells);
    var d = classesWithBugSmells(classesWithBadSmells);
    // FIXME: 16.1 is not "almost sixteen"
    // TODO: Write a sentence about the most bug-prone classes
    // FIXME: Make sentences less repetitive regarding phrasing
    text+= 'Almost ' + num2word(Math.round((bugCt/classCt)*100)) + ' percent <span id="bar_17" class="barSpan"></span> of the classes were associated with recorded bugs.';
    if(d.length > 3){
      text += ' The classes <button class="collapsible"></button><div class="content"><p>' + printItalicsList(d) + '</p></div> were associated with bugs and have identified bad smells';
    }
    else if (d.length > 0){
      text += (d.length == 1) ? ' The class ' + printItalicList(d) + ' was ' : ' The classes ' + printItalicList(d) + ' were ' ;
      text += 'associated with recorded bugs and '+((d.length == 1)?'has':'have')+' identified bad smells.';
    }

  }

  return text;
}

	html = html.replace(/PROJECTNAME/g, ""+projectName).replace(/ClASSCT/g, ""+classCt).replace(/BADCT/g, ""+badCt).replace(/BUGCT/g, ""+bugCt).replace(/BLOBCT/g, ""+blobCt).replace(/DECOMCT/g, ""+decomCt).replace(/SPACT/g, ""+spaCt).replace(/BLOBLIST/g, ""+blobList).replace(/LAZYCT/g, ""+lazyCt);
  html = html.replace(/DECOMLIST/g, ""+decomList).replace(/SPALIST/g, ""+spaList).replace(/HIGHBLOB/g, ""+highblobList).replace(/LAZYLIST/g, ""+lazyList).replace(/BUGLIST/g, ""+bugList);
  html = html.replace(/GOODCOUPLINGLIST/g, ""+goodCouplingList).replace(/GOODCOUPLINGCT/g, ""+goodCouplingCt).replace(/GOODCOUPLINGPT/g, ""+goodCouplingPercent).replace(/REGULARCOUPLINGLIST/g, ""+regularCouplingList).replace(/REGULARCOUPLINGCT/g, ""+regularCouplingCt).replace(/REGULARCOUPLINGPT/g, ""+regularCouplingPercent).replace(/BADCOUPLINGLIST/g, ""+badCouplingList).replace(/BADCOUPLINGCT/g, ""+badCouplingCt).replace(/BADCOUPLINGPT/g, ""+badCouplingPercent);
  html = html.replace(/GOODINHERITANCELIST/g, ""+goodInheritanceList).replace(/GOODINHERITANCECT/g, ""+goodInheritanceCt).replace(/REGULARINHERITANCELIST/g, ""+regularInheritanceList).replace(/REGULARINHERITANCECT/g, ""+regularInheritanceCt).replace(/BADINHERITANCELIST/g, ""+badInheritanceList).replace(/BADINHERITANCECT/g, ""+badInheritanceCt);
  html = html.replace(/BADCOHESIONLIST/g, ""+badCohesionList).replace(/BADCOHESIONCT/g, ""+badCohesionCt).replace(/REGULARCOHESIONLIST/g, ""+regularCohesionList).replace(/REGULARCOHESIONCT/g, ""+regularCohesionCt).replace(/GOODCOHESIONLIST/g, ""+goodCohesionList).replace(/GOODCOHESIONCT/g, ""+goodCohesionCt);
  html = html.replace(/GOODCOMPLEXITYLIST/g, ""+goodComplexityList).replace(/GOODCOMPLEXITYCT/g, ""+goodComplexityCt).replace(/REGULARCOMPLEXITYLIST/g, ""+regularComplexityList).replace(/REGULARCOMPLEXITYCT/g, ""+regularComplexityCt).replace(/BADCOMPLEXITYLIST/g, ""+badComplexityList).replace(/BADCOMPLEXITYCT/g, ""+badComplexityCt);
  html = html.replace(/BBLIST/g, ""+bugBlobArr[0]).replace(/BDLIST/g, ""+bugDecomList).replace(/BLOBDECOMSMELLSLIST/g, ""+blobDecomArr[0]).replace(/BLOBSPASMELLSLIST/g, ""+blobSpaArr[0]).replace(/BLOBLAZYSMELLSLIST/g, ""+blobLazyArr[0]);
  html = html.replace(/SUPERSMELLSLIST/g, ""+superSmellsList)
   html = html.replace(/PROJINFO/g,""+projInfo).replace(/NUMBEROFPACKAGES/g, ""+numberOfPackages);

	$("#textBPanel").html(html);

	$(".className").click(function(){
		var idx = Number($(this).attr("data-index"));
    var str = data[idx].cname;
		var url = "sourcecode/src/" + str.replace(/[.]/g, "/") + ".java";
    $("#detailsHeader").text("File "+str.split(".").pop()+ ".java");
    $("#detailsContent").empty();
    $("#detailsContent").append($('<pre id="sourcecodeContainer"><code id="sourcecode" class="language-java"></code></pre>'));
    // TODO: replace by asynchronous load
    var src = $.ajax({
      url: url,
      async: false
    }).responseText;
    src = src.substring(src.indexOf("package "));   // cut out license text
    $("#sourcecode").text(src);
    Prism.highlightElement($("#sourcecode")[0]);
	});

  /* TODO: reimplement a proper package details page
  $(".pack").click(function(){
    var idx = Number($(this).attr("data-index"));
		var str = data[idx].cname;
    var classUrl = str.replace(/[.]/g, "/");
    var n = classUrl.search(str.split(".").pop());
    var curl = classUrl.substring(0,n);
	//	var url = "http://svn.apache.org/viewvc/xerces/java/branches/xerces_j_1/src/"+curl;
    var url = "https://svn.apache.org/repos/asf/xerces/java/branches/xerces_j_1/src/"+curl;
    $("#detailsHeader").text("Package "+url);
    $("#detailsContent").empty();
    $("#detailsContent").load(curl, function() {
    });   
	});*/

  var sparklineOptions = {
    type:'bar',
    width: '30px',
    height: '30px',
    highlightLighten: 1.1,
    highlightColor: 'black',
  }


  //bad smells charts
	drawBarChart("#barBlob", Math.round((blobCt/badCt)*1000)/10);
	drawBarChart("#barFc", Math.round((decomCt/badCt)*1000)/10);
	drawBarChart("#barSpa", Math.round((spaCt/badCt)*1000)/10);
  drawBarChart("#barLazy", Math.round((lazyCt/badCt)*1000)/10);
  // coupling charts
  drawBarChart("#bar_5", Math.round((goodCouplingCt/classCt)*1000)/10);
  drawBarChart("#bar_6", Math.round((regularCouplingCt/classCt)*1000)/10);
  drawBarChart("#bar_7", Math.round((badCouplingCt/classCt)*1000)/10);
  //Inheritance charts
  drawBarChart("#bar_8", Math.round((goodInheritanceCt/classCt)*1000)/10);
  drawBarChart("#bar_9", Math.round((regularInheritanceCt/classCt)*1000)/10);
  drawBarChart("#bar_10", Math.round((badInheritanceCt/classCt)*1000)/10);
  // Cohesion charts
  drawBarChart("#bar_11", Math.round((goodCohesionCt/classCt)*1000)/10);
  drawBarChart("#bar_12", Math.round((regularCohesionCt/classCt)*1000)/10);
  drawBarChart("#bar_13", Math.round((badCohesionCt/classCt)*1000)/10);
  // Complexity charts
  drawBarChart("#bar_14", Math.round((goodComplexityCt/classCt)*1000)/10);
  drawBarChart("#bar_15", Math.round((regularComplexityCt/classCt)*1000)/10);
  drawBarChart("#bar_16", Math.round((badComplexityCt/classCt)*1000)/10);

  //bug chart
  drawBarChart("#bar_17", Math.round((bugCt/classCt)*1000)/10);


  //columns
  // console.log(data);
	// var columns = data.columns;

	// var LOC_S = (columns.indexOf("LOC") >= 0)? "LOC" : "loc",
	// 	AMC_S = (columns.indexOf("AMC") >= 0)? "AMC" : "amc",
	// 	WMC_S = (columns.indexOf("WMC") >= 0)? "WMC" : "wmc",
  //   NPM_S = (columns.indexOf("NPM") >= 0)? "NPM" : "npm";
    

	$(".smellBlob").on("click", function(){
    var url = "bad_smell_descriptions/blob.htm";
    $("#detailsHeader").text("The 'God Class' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(blobCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.blob);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[LOC_S] = [1500, null];
			dims[AMC_S] = [129, null];

      parallelfilter(dims);
		}
	});

	$(".smellFc").on("click", function(){
    var url = "bad_smell_descriptions/fd.htm";
    $("#detailsHeader").text("The 'Functional Decomposition' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(decomCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.decomposition);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[NPM_S] = [null, 8];
			dims[WMC_S] = [16, null];
			parallelfilter(dims);
		}
	});

	$(".smellSpa").on("click", function(){
    var url = "bad_smell_descriptions/sc.htm";
    $("#detailsHeader").text("The 'Spaghetti Code' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(spaCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.spaghetti);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[AMC_S] = [151, null];
			parallelfilter(dims);
		}
	});

  $(".smellLazy").on("click", function(){
    var url = "bad_smell_descriptions/lazy.htm";
    $("#detailsHeader").text("The 'Lazy Class' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(lazyCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.lazy);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[WMC_S] = [0, 0.1];
			parallelfilter(dims);
		}
	});

  $(".couplingMetric").on("click", function(){
    showCouplingMetricDescription();
  });

  $(".complexityMetric").on("click", function(){
    showComplexityMetricDescription();
  });

  $(".cohesionMetric").on("click", function(){
    showCohesionMetricDescription();
  });

  $(".inheritanceMetric").on("click", function(){
    showInheritanceMetricDescription();
  });

  if(linkedSLopts != null) $(document).linkedSparklines(linkedSLopts);  //added

/* ------------------------------------------------------------------------*/
/* Methodological Explainations - Tooltips */ 
/* ------------------------------------------------------------------------*/
  var couplingMethod = "We use thresholds values of cbo, ce, and ca for categorizing coupling as good, regular, or bad.<br><br> Good: cbo, ce 	&#8804; 6; ca<=7,  <br> Regular: cbo, ca &isin; [7,39]; <br> Bad: cbo, ca > 39; ce > 16";

  var complexityMethod = "We use thresholds values of cbo, ce, and ca for categorizing coupling as good, regular, or bad.<br><br> Good: max_cc &#8804; 2; wmc 	&#8804; 11,  <br> Regular: max_cc &isin; (2,4]; wmc &isin; (11,34) <br> Bad: max_cc > 4; wmc >34";

  var cohesionMethod = "We use thresholds values of cbo, ce, and ca for categorizing coupling as good, regular, or bad.<br><br> Good: lcom3 &#8804; 0.167; <br> Regular: lcom3 &isin; (0.167,0.725]; <br> Bad: lcom3 > 0.725";

  var inheritanceMethod = "We use thresholds values of cbo, ce, and ca for categorizing coupling as good, regular, or bad.<br><br> Good: dit 	&#8804; 2; noc <= 1 <br> Regular: dit &isin; (2,4]; noc &isin; (1,3]  <br> Bad: dit > 4; noc > 3";

  
  $( ".projInfo" ).tooltip({
      content: projInfo
  });
  $( ".couplingInfo" ).tooltip({
      content: couplingMethod
  });
  $( ".complexityInfo" ).tooltip({
      content: complexityMethod
  });
  $( ".cohesionInfo" ).tooltip({
      content: cohesionMethod
  });
  $( ".inheritanceInfo" ).tooltip({
      content: inheritanceMethod
  });

  // TODO: implement the color legends for labels in paracoord
  // $("#parallelplot").contents().find("text.label").attr('text-decoration','underline');
  
  // FIXME: Not working as iframe loades after the command is executed
  //  $("#scatterplot").contents().find("select#xSelect :selected").val();

/* ------------------------------------------------------------------------*/
/* Calling the Visualization functions to draw visualizations */
/* ------------------------------------------------------------------------*/

  parallelplot(data);
  makeScatterPlot(data);

}
function structurize(paths) {
      var items = [];
      for(var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];
          var name = path[0];
          var rest = path.slice(1);
          var item = null;
          for(var j = 0, m = items.length; j < m; j++) {
              if(items[j].name === name) {
                  item = items[j];
                  break;
              }
          }
          if(item === null) {
              item = {name: name, children: []};
              items.push(item);
          }
          if(rest.length > 0) {
              item.children.push(rest);
          }
      }
      for(i = 0, l = items.length; i < l; i++) {
          item = items[i];
          item.children = structurize(item.children);
      }
      return items;
  }

  function stringify(items) {
      var lines = [];
      for(var i = 0, l = items.length; i < l; i++) {
          var item = items[i];
          lines.push(item.name);
          var subLines = stringify(item.children);
          for(var j = 0, m = subLines.length; j < m; j++) {
              lines.push("  " + subLines[j]);
          }
      }
      return lines;
  }

function drawBarChart(tagNmae, val){
	$(tagNmae).html('<svg width="50" height="14" style="background: #ccc;"><g transform="translate(0,0)" style="text-anchor: middle;"><rect class="bar" width="'+(val/2)+'" height="14"></rect><text x="25" y="11" style="font-size:12px">'+val+'%</text></g></svg>');
}

/* ------------------------------------------------------------------------*/
/* Click and hover events */
/* ------------------------------------------------------------------------*/

// TODO: also show the metric description in the details panel
$(document).on("click","button.collapsible", function () {
   $(this)[0].classList.toggle("active");
   var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
});

//Highlighting corresponding element of vis on hovering class name in text
$(document).on("mouseover", ".className", function() {
    var className = $(this).text();
    $("span.slcls."+className+"",window.parent.document).css('background','#ffe68e');
    $("#scatterplot").contents().find("circle#"+className).attr("r","6").attr("stroke", "#ffe68e").attr("stroke-width","4px");
    
    //Highlighting edge of parallel coordinates when hovering over dot in scatter plot
    var d = window.parent.fullData;
    highlightEdge(d[classShortNameToIndex[className]]);
    
    //appending to parcoord caption 
    var bs = findBadSmellsInClass(className);
    $('#captionPP').append('<span id="dynamicCaption"></span>');
    $('#dynamicCaption').append(createClassSpan(className) + ' contains ' + printList(bs) + ' bad smells.');

 }).on('mouseout', '.className', function() {
    $("span.slcls",window.parent.document).css('background',''); 
    $("#scatterplot").contents().find("circle").attr("r","3").attr("stroke", "").attr("stroke-width","0px");
    unHighlight();

    //reset to original caption
    $('#dynamicCaption').remove();
 });

/* ------------------------------------------------------------------------*/
/* Metric descriptions */
/* ------------------------------------------------------------------------*/

// TODO: color metric names accordingly

function showCouplingMetricDescription() {
  var content = '<p>The metrics coupling between objects (<span class="cbo">cbo</span>), afferent coupling (<span class="ca">ca</span>), and efferent coupling (<span class="ce">ce</span>) are used to assess quality in terms of coupling. We use thresholds of the metrics to classify the individual classes as having good, regular, or bad coupling.</p>';

  content += '</p>For instance, ' + createClassSpan(findClassWithMaxValueOfMetricX('cbo')) + ' has high coupling. </p>';

  updateDetailPanel("Coupling", content);
}

function showComplexityMetricDescription() {
  var content = '<p>The metrics weighted method per class (<span class="wmc">wmc</span>) and cyclomatic complexity (<span class="max_cc">cc</span>) contribute towards the code complexity of a class. </p>';
  
    content += '</p>For instance, ' + createClassSpan(findClassWithMaxValueOfMetricX('max_cc')) + ' has high complexity. </p>';
  
  updateDetailPanel("Complexity", content);
}

function showCohesionMetricDescription() {
  var content = '<p>Two versions of lack of cohesion metric, i.e., <span class="lcom">ce</span> and <span class="lcom3">lcom3</span> show the quality in terms of cohesion.</p>';

  content += '</p>For instance, ' + createClassSpan(findClassWithMaxValueOfMetricX('lcom')) + ' has maximum cohesion. </p>';

  updateDetailPanel("Cohesion", content);
}

function showInheritanceMetricDescription() {
  var content = '<p>The metrics depth of inheritance (<span class="dit">dit</span>) and number of children (<span class="noc">noc</span>) are used to assess the quality in terms of inheritance.</p>';

  content += '</p>For instance, ' + createClassSpan(findClassWithMaxValueOfMetricX('noc')) + ' has high inheritance. </p>';

  updateDetailPanel("Inheritance", content);
}

/* ------------------------------------------------------------------------*/
/* Util functions */ 
/* ------------------------------------------------------------------------*/

function findClassWithMaxValueOfMetricX (X){
  var max =  Math.max.apply(Math, fullData.map(function(o) { return o[X]; }))
  var maxClass = fullData.filter(function(d){ return d[X] == max;})[0];
  
  return maxClass.cname;
}

function createClassSpan(cname) {
  var i = classFullNameToIndex[cname]? classFullNameToIndex[cname]: classShortNameToIndex[cname]; // TODO always use full names internally
  return "<span class='className clickable' data-index='" + i + "'>" + cname.split(".").pop() + "</span>";
}

function printList(list){
    var s="";
    switch(list.length){
      case 1: s += list[0]; break;
      case 2: s +=  list[0] + " and " + list[1]; break;
      default:
        for(var i=0; i<list.length; i++){
          if (i != list.length-1){
            s += list[i]+ ", ";
          }
          else s += " and " + list[i];
        }
    }
    return s;
  }

// TODO: rename and use printList() here instead of a code clone
function printItalicList(list){
  var s="";
  switch(list.length){
    case 1: s += createClassSpan(list[0]); break;
    case 2: s += createClassSpan(list[0])+ ' and ' + createClassSpan(list[1]); break;
    default:
      for(var i=0; i<list.length; i++){
        if (i != list.length-1){
          s += createClassSpan(list[i]) + ", ";
        }
        else s += " and " + createClassSpan(list[i]);
      }
  }
  return s;
}

// TODO: use this util function consistently
function updateDetailPanel(title, content) {
  $("#detailsHeader").text(title);
  $("#detailsContent").empty();
  $("#detailsContent").append($(content));
}

function num2word(n){
  if (numToWord[n] != undefined){
    return numToWord[n];
  }
  else return n;
}

function findBadSmellsInClass(className){
  //use global data variable called fullData
  var bs = [];
  if (fullData[classShortNameToIndex[className]].smells['blob']){ bs.push('God Class')};
  if (fullData[classShortNameToIndex[className]].smells['decomposition']){ bs.push('Functional Decomposition')}; 
  if (fullData[classShortNameToIndex[className]].smells['spaghetti']){ bs.push('Spaghetti Code')}; 
  if (fullData[classShortNameToIndex[className]].smells['lazy']){ bs.push('Lazy Class')}; 

  return bs;
}

// TODO: use consistently
function createCollapsibleClassList(list) {
   return '<button class="collapsible"></button><div class="content">' + printList(list) + '</div>';
}

/* ------------------------------------------------------------------------*/
/* Parallel Coordinates */ 
/* ------------------------------------------------------------------------*/
 // load csv file and create the chart
function parallelplot(data) {
  console.log(data);
	data.forEach(function(d, i){
		// delete d.cname;
		delete d.rfc;
		delete d.dam;
		delete d.moa;
		delete d.mfa;
		delete d.cam;
		delete d.ic;
		delete d.cbm;
		delete d.avg_cc;
	});
	// console.log(data[0]);

	//specify the dimensions and their order
	var myDimensions = {
		"wmc": {type:"number"},
		"max_cc": {type:"number"},
		"cbo":{type:"number"},
		"ca": {type:"number"},
		"ce": {type:"number"},
		"lcom": {type:"number"},
		"lcom3": {type:"number"},
		"noc": {type:"number"},
		"dit": {type:"number"},
		"loc": {type:"number"},
		"amc": {type:"number"},
		"npm": {type:"number"},
	};

  // TODO: replace this 12 with number of dimensions variable
	//var w = (12)*52.55;
	//$("#example_container").css({width: w+"px"});
	//$("#example").css({width: w+"px"});
  pcz = d3.parcoords()("#example")
    .data(data)
    .hideAxis(["name"])
    .composite("darken")
		.color(function(d) {
      var class_smells = data[classFullNameToIndex[d.cname]].smells; 
      if(class_smells['blob'] || class_smells['decomposition'] || class_smells['spaghetti'] || class_smells['lazy']){
          return 'black'
      }
      else return "#d6d6d6";
    })
		.hideAxis(['cname'])
		.dimensions(myDimensions)
    .render()
    // .alpha(0.6)
    .brushMode("1D-axes")  // enable brushing
		.interactive(); // command line mode
		
  // adding axis labels
  pcz.svg.selectAll(".dimension")
    .selectAll(".label")
		.style("font-size", "14px");

}
function unHighlight(){
	//clearing the highlighting
	pcz.unhighlight();
	// pcz.color(function(d) { return "steelblue"; });
	// pcz.clear('highlight');
	// d3.select("canvas.foreground.faded").classed("faded", false);
}
function highlightEdge(d){
	// console.log(d);
		var classData = {cname:d.cname,
						amc: d.amc,
						bug: d.bug,
						ca: d.ca,
						cbo: d.cbo,
						ce: d.ce,
						dit: d.dit,
						lcom: d.lcom,
						lcom3: d.lcom3,
						loc: d.loc,
						max_cc: d.max_cc,
						noc: d.noc,
						npm: d.npm,
						wmc: d.wmc};
	pcz.highlight([classData]);
}

function parallelfilter(dims) {
	// console.log(dims);
	for(var dim in dims){
		var domain = pcz.dimensions()[dim].yscale["domain"]();

		if(dims[dim][0] == null){
			dims[dim][0] = Math.min(domain[0], domain[1]);
		}

		if(dims[dim][1] == null){
			dims[dim][1] = Math.max(domain[0], domain[1]);
		}
	}

	pcz.brushReset();
	pcz.brushExtents(dims);
}

/* ------------------------------------------------------------------------*/
/* Scatter Plot */ 
/* ------------------------------------------------------------------------*/
// TODO: Fix size and layout of scatterplot 
function makeScatterPlot(data){
  
  var root = d3.select('#controls');
  var tooltip = d3.select('#tooltip').style("opacity", 0);

    var OUTLIER_THRESHOLD = 15, selectData = [], prev_data, excluded_keys = ["smells","cname", "index", "neighbors", "rfc", "dam", "moa", "mfa", "cam", "ic", "cbm", "avg_cc"], prev_options = {}, dimensions = [];
  
    prev_data = clone(data);
    

    var columns = Object.keys(data[0]);
    selectData = [];
    for(var c in columns) {
        if(excluded_keys.indexOf(columns[c]) == -1) {
            selectData.push({text: columns[c]});
        }
    }

    setup(data);

    function xChange(){
        prev_options.xSelect = this.value;
        if(prev_data) {
            var chart_data = clone(prev_data);
            console.log(this.value);
            console.log(chart_data);
            setup(chart_data);
        }
    }

    function yChange(){
        prev_options.ySelect = this.value;
        if(prev_data) {
            var chart_data = clone(prev_data);
            setup(chart_data);
        }
    }

    function updateThreshold(){
        const thresh = OUTLIER_THRESHOLD;
        try {OUTLIER_THRESHOLD = parseInt(document.getElementById("outlierInput").value);} catch(e){}
        if(thresh != OUTLIER_THRESHOLD) {
            var chart_data = clone(prev_data);
            setup(chart_data);
        }
    }

    function setup(data){
        // console.log(data);
        try {OUTLIER_THRESHOLD = parseInt(document.getElementById("outlierInput").value);} catch(e){}

        d3.selectAll('#controls>*').remove();

        var xSpan = root.append('span')
            .text('X-axis: ');

        var xInput = root.append('select')
            .attr('id','xSelect')
            .on('change', xChange)
            .selectAll('option')
            .data(selectData)
            .enter()
            .append('option')
            .attr('value', function (d) { return d.text })
            .text(function (d) { return d.text ;});

        var ySpan = root.append('span')
            .text(' Y-Axis: ')

        var yInput = root.append('select')
            .attr('id','ySelect')
            .on('change',yChange)
            .selectAll('option')
            .data(selectData)
            .enter()
            .append('option')
            .attr('value', function (d) { return d.text })
            .text(function (d) { return d.text ;});

        dimensions = [];
        d3.keys(data[0]).map(function(item){
            try {if(item != "cname" && !isNaN(parseFloat(data[0][item]))) {
                dimensions.push(item);
            }} catch(e){}
        });

        var dims = {};
        var dimension = [dimensions[0], dimensions[0]];
        try {if(prev_options.xSelect != null) {
            document.getElementById("xSelect").value = prev_options.xSelect;
            dimension[0] = prev_options.xSelect;
            dims[dimension[0]] = [null, 0];
        }} catch(e){}
        try {if(prev_options.ySelect != null) {
            document.getElementById("ySelect").value = prev_options.ySelect;
            dimension[1] = prev_options.ySelect;
            dims[dimension[1]] = [null, 0];
        }} catch(e){}
        

        d3.selectAll("#chart>*").remove();
        var w = d3.select("#chart").style("width");
        var scatterplot = ScatterPlot().$el("#chart").size(145).threshold(12).margin(40).threshold(OUTLIER_THRESHOLD)
            .dotRadius(4).dotOpacity(1).dimensions(dimension).data(data).mouseover(function(d, i){
                tooltip.style("opacity", 1)
                    .html((d.cname ? d.cname.split(".").pop() : ("label" + d.index.toString())))
                    .style("left", (d3.event.pageX - 155) + "px")  // specify x location
                    .style("top", (d3.event.pageY - 110) + "px");  // specify y location
            }).mouseout(function(d){
                tooltip.style("opacity", 0);
            });
        scatterplot.render();
    }
  function scatterfilter(newdata){
		var g = d3.select("#chart svg g");
		g.selectAll(".dot")
			.style("fill", function(d,i) { return newdata[i]? "black": "#d6d6d6";} );

    }
}

</script>
</html>
