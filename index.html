<!DOCTYPE html>
<html>
<header>
  <meta charset="utf-8">
  <script type="text/javascript" src="lib/jquery-2.2.2.min.js"></script>
  <script type="text/javascript" src="lib/jquery.sparkline.js"></script>
  <script type="text/javascript" src="lib/prism.js"></script>
  <script type="text/javascript" src="lib/jquery.sparkline.min.js"></script>
  <script type="text/javascript" src="lib/jquery-ui.js"></script>
  <script type="text/javascript" src="lib/d3.min.js"></script>
  <script type="text/javascript" src="lib/bboxCollide.js"></script>
  <script type="text/javascript" src="lib/d3-annotation.js"></script>
  <script type="text/javascript" src="js/parcoords.js"></script>
  <script type="text/javascript" src="js/mysparklines.js"></script>
  <script type="text/javascript" src="js/scatterplot.js"></script>
  <script type="text/javascript" src="js/text.js"></script>
  <script src="lib/simple-statistics.min.js"></script>
  <link rel="stylesheet" href="lib/jquery-ui.css"  type='text/css' media='all'>
  <link rel="stylesheet" href="lib/prism.css"  type='text/css' media='all' />
  <link rel="stylesheet" href="css/parcoords.css"  type='text/css' media='all'>
  <link rel='stylesheet' href='css/mysparklines.css' type='text/css' media='all' />
  <link rel='stylesheet' href='css/main.css' type='text/css' media='all' />
  <title>Code Quality Documents</title>
</header>
<body>
  <div id="grid-container">
    <div id="header">
      <input id="file-upload" type="file" value="Upload" onchange="handleFileSelect(event)" />
      <div id="title">Code Quality Documents </div>
      <div id="subtitle"></div>
    </div>
    <div id="textPanel">
      <div id="textAPanel"></div>
      <div id="textBPanel"></div>
    </div>
    <div id="vis">
      <div id="parallelplot" class="parcoords"></div>
      <div id="scatterplot">
        <div id="controls"></div>
        <div id="chart_container">
          <div id="chart"></div>
          <div id="tooltip" class="tooltip"></div>
        </div>
      </div>
      <div id="captionPP"></div>
    </div>
    <div id="details">
      <h3 id="detailsHeader"></h3>
      <div id="detailsContent"></div>
    </div>
  </div>
</body>

<script type="text/javascript">

/* ------------------------------------------------------------------------*/
/* Global variables */
/* ------------------------------------------------------------------------*/

var projectName = "";
var fullData;
var badClasses;
var classFullNameToIndex = {}; // dictionary to retrieve idicies by class name efficiently
var classShortNameToIndex = {} // equivalent dictionary with short class names -- TODO: temporary solution, should be removed
var xVal; //variables to store active values of scatterplot dimensions
var yVal; //variables to store active values of scatterplot dimensions
var classesWithBadSmells = [];
var haveClassToPersist = false;
var persistentClass = "";
var scatterPlotDimensions=[];

var LOC, AMC, WMC, NPM;
    
var linkedSLopts = null;    //added

var badCt = 0, bugCt = 0, bugBlobCt = 0, bugDecomCt = 0, blobDecomCt = 0, blobSpaCt = 0, blobLazyCt = 0, superSmellsCt = 0, classCt = 0, blobCt = 0, blobList = "", bugList = "", blobArr = [], bugArr = [], goodCouplingArr = [], regularCouplingArr = [], badCouplingArr = [], goodComplexityArr = [], regularComplexityArr = [], badComplexityArr = [], goodInheritanceArr = [], regularInheritanceArr = [], badInheritanceArr = [], goodCohesionArr = [], regularCohesionArr = [], badCohesionArr = [], bugBlobArr = [], bugDecomArr = [], blobDecomArr = [], blobSpaArr = [], blobLazyArr = [], superSmellsArr = [], goodCouplingList = "", regularCouplingList = "", badCouplingList = "",  goodInheritanceList = "", regularInheritanceList = "", badInheritanceList = "", goodCohesionList = "", regularCohesionList = "",  badCohesionList = "", goodComplexityList = "", regularComplexityList = "", badComplexityList = "", bugBlobList = "", bugDecomList = "", blobDecomList = "", blobSpaList = "", blobLazyList = "", superSmellsList = "", decomCt = 0, decomList = "", decomArr = [], spaCt = 0, spaList = "", spaArr = [], highblobCt = 0, highblobList = "", highblobArr = [], lazyCt = 0, lazyList = "", lazyArr = [], blobTag = false, decomTag = false, projInfo = "", numberOfPackages = 0, bugSpaArr = [], bugLazyArr = [], bugSpaList = "", bugLazyList = "", bugSpaCt = 0, bugLazyCt = 0, spaTag = false, lazyTag = false;

/* ------------------------------------------------------------------------*/
/* Load data and generate report */ 
/* ------------------------------------------------------------------------*/

function handleFileSelect(event) {
	// Check for the various File API support.
	if (window.File && window.FileReader && window.FileList && window.Blob) {
		// Great success! All the File APIs are supported.
	} else {
		alert('The File APIs are not fully supported in this browser.');
	}

  
  // hide text until bar charts are completely loaded
	$("#textPanel > div").css({visibility: "hidden"});
	var f = event.target.files[0]; // FileList object
	projectName = f.name.replace('.csv','');
	var reader = new FileReader();
	reader.onload = function(event) {
		setTimeout(function(){
      d3.csv(event.target.result, function(data) {
        generateReport(data);
      });
		}, 2000);
	};

	// Read in the file as a data URL.
  reader.readAsDataURL(f);
  
	//modified
	linkedSLopts = {
                  csvurl: encodeURI("csv/"+f.name),
                  slids: ['slComplexity', 'slCoupling', 'slCohesion', 'slInheritance'],     //pass ids for containers of first and second graph
                  sldef: ['wmc,max_cc', 'cbo,ca,ce', 'lcom3', 'dit,noc'], //pass fields for graphs
                  slopts: [
                            {height: 25}, //pass Sparklines options, dafaults to {type: 'bar', disableHiddenCheck: true, height: 200, barWidth: 4}
                            //pass options specfic to each sl if required, in order
                            {stackedBarColor: ['#2b8cbe','#56baec']},
                            {stackedBarColor: ['#238b45','#3dc56b','#65e48f']},
                            {stackedBarColor: ['#c51b8a','#fa9fb5']},
                            {stackedBarColor: ['#8b5400','#cf891f']},
                          ],
                  //HLclass: 'hl',                       //pass class used to high  //function to run on success, null by defaultlight linked bar, defaults to 'hl'
                  fn_wrapup: function() {   //function to run on success, null by default
                                      $(".content").hide();
                                      $("#textPanel > div").css({visibility: "visible"});
                                     }
                 }
  //end of modified
}

function generateReport(data){
  analyzeData(data);
  generateText(data);
  parallelplot(data);
  makeScatterPlot(data);
}

/* ------------------------------------------------------------------------*/
/* Analyze data */ 
/* ------------------------------------------------------------------------*/

function analyzeData(data){

  classCt = data.length;

  //making data available to all files
  fullData = data;
	data.forEach(function(d, i){
		d.index = i;
		d.smells = {
			blob: false,
			decomposition: false,
			spaghetti: false,
      highblob : false,
      lazy: false,
		};  

    LOC = d["LOC"] || d["loc"],
			AMC = d["AMC"] || d["amc"],
			WMC = d["WMC"] || d["wmc"],
      NPM = d["NPM"] || d["npm"];

		if(LOC >= 1500 && AMC >= 129){
			d.smells.blob = true;
		}

    if(LOC >= 8000 && AMC >= 129){
			d.smells.highblob = true;
		}

		if(NPM <= 8 && WMC >= 16){
			d.smells.decomposition = true;
		}

		if(AMC >= 151){
			d.smells.spaghetti = true;
		}

    if(WMC == 0){
      d.smells.lazy = true;
    }
	});

	data.forEach(function(d, i){
    classFullNameToIndex[d.cname] = i; 
    classShortNameToIndex[d.cname.split(".").pop()] = i;
    var s = d.smells;
    var badClass = new Object;
    var badSmellsinClass = [];

    var bad = false;
    
    var classSpan = createClassSpan(d.cname);

    // TODO: remove code clones in the following

		if(s.blob){
			blobCt++;
      blobArr.push(classSpan);
      bad = true;

      badSmellsinClass.push("Large Class");
		}

    if(s.highblob){
      highblobCt++;
      highblobArr.push(classSpan);
      //bad = true;


    }

		if(s.decomposition){
      decomCt++;
      decomArr.push(classSpan);
			bad = true;
      badSmellsinClass.push("Functional Decomposition");
		}

		if(s.spaghetti){
      spaCt++;
      spaArr.push(classSpan);
      bad = true;

      badSmellsinClass.push("Spaghetti Code");
		}

    if(s.lazy){
      lazyCt++;
      lazyArr.push(classSpan);
      badSmellsinClass.push("Lazy Class");
    }

    if(d.bug >= 1){

      bugCt++;
      bugArr.push(classSpan);
    }

		if(bad){
			badCt++;
    }
    if (s.lazy || s.spaghetti || s.decomposition || s.blob || d.bug > 0){
      badClass.name =  d.cname.split(".").pop();
      badClass.badSmells = badSmellsinClass;
      badClass.bug = d.bug;
      classesWithBadSmells.push(badClass);
    }
    badClasses = classesWithBadSmells;

    if (d.max_cc > 4 || d.wmc > 34) {
      badComplexityArr.push(classSpan);
    } else if (d.max_cc > 2 || d.wmc > 11) {
      regularComplexityArr.push(classSpan);
    } else {
      goodComplexityArr.push(classSpan);
    }

    if (d.cbo >= 9 || d.ca > 39 || d.ce > 16) {
      badCouplingArr.push(classSpan);
    } else if (d.cbo >= 7 || d.ca > 7 || d.ce > 6) {
      regularCouplingArr.push(classSpan);
    } else {
      goodCouplingArr.push(classSpan);
    }
    
    if (d.lcom3 > 0.725) {
      badCohesionArr.push(classSpan);
    } else if (d.lcom3 > 0.167) {
      regularCohesionArr.push(classSpan);
    } else {
      goodCohesionArr.push(classSpan);
    }
    
    if (d.dit > 4 || d.noc > 3) {
      badInheritanceArr.push(classSpan);
    } else if (d.dit > 2 || d.noc > 1) {
      regularInheritanceArr.push(classSpan);
    } else {
      goodInheritanceArr.push(classSpan);
    }
  })

  for(var i = 0; i < bugArr.length; i++){
    var b = bugArr[i];
    if(i == 0){
      bugList += b;
    }else if(i == bugArr.length-1){
      bugList += " and "+b;
    }else{
      bugList += ", "+b;
    }
  }

	for(var i = 0; i < blobArr.length; i++){
		var b = blobArr[i];
		if(i == 0){
			blobList += b;
		}else if(i == blobArr.length-1){
			blobList += " and "+b;
		}else{
			blobList += ", "+b;
		}
	}

  for(var i = 0; i < highblobArr.length; i++){
		var b = highblobArr[i];
		if(i == 0){
			highblobList += b;
		}else if(i == highblobArr.length-1){
			highblobList += " and "+b;
		}else{
			highblobList += ", "+b;
		}
	}

	for(var i = 0; i < decomArr.length; i++){
		var b = decomArr[i];
		if(i == 0){
			decomList += b;
		}else if(i == decomArr.length-1){
			decomList += " and "+b;
		}else{
			decomList += ", "+b;
		}
	}

	for(var i = 0; i < spaArr.length; i++){
		var b = spaArr[i];
		if(i == 0){
			spaList += b;
		}else if(i == spaArr.length-1){
			spaList += " and "+b;
		}else{
			spaList += ", "+b;
		}
	}

  for(var i = 0; i < lazyArr.length; i++){
		var b = lazyArr[i];
		if(i == 0){
			lazyList += b;
		}else if(i == lazyArr.length-1){
			lazyList += " and "+b;
		}else{
			lazyList += ", "+b;
		}
	}

  for(var i = 0; i < goodCouplingArr.length; i++){
    var b = goodCouplingArr[i];
    if(i == 0){
      goodCouplingList += b;
    }else if(i == goodCouplingArr.length-1){
      goodCouplingList += " and "+b;
    }else{
      goodCouplingList += ", "+b;
    }
  }


  //check for classes having both bad smells and bugs
  var m = 0, n = 0;
  for(var i = 0; i < bugArr.length; i++){
    var str1 = bugArr[i].split('<i>').pop().split('</i>')[0];
    if(blobList.includes(str1) === true)
      {
        bugBlobArr[m] = bugArr[i];
        m++;
        bugBlobList+= str1 + " ";

        bugBlobCt+=1;
        blobTag = true;
      }
    if(decomList.includes(str1) === true)
      {
        bugDecomArr[n] = bugArr[i];
        n++;
        bugDecomList+= str1 + " ";
        bugDecomCt+=1;
        decomTag = true;
      }
      if(spaList.includes(str1) === true)
      {
        bugSpaArr[m] = spaArr[i];
        m++;
        bugSpaList+= str1 + " ";

        bugSpaCt+=1;
        spaTag = true;
      }
    if(lazyList.includes(str1) === true)
      {
        bugLazyArr[n] = bugArr[i];
        n++;
        bugLazyList+= str1 + " ";
        bugLazyCt+=1;
        lazyTag = true;
      }
  }

  //check for classes having multiple bad smells
  var j = 0, k = 0, l = 0;
  for(var i = 0; i < blobArr.length; i++){
    var str1 = blobArr[i].split('<i>').pop().split('</i>')[0];
    if(decomList.includes(str1) === true)
      {
        blobDecomArr[j] = blobArr[i];
        superSmellsArr[i] = blobDecomArr[j];
        j++;
        blobDecomList+= str1 + " ";
        blobDecomCt+=1;
        superSmellsCt+=1;
    }
    if(spaList.includes(str1) === true)
      {
        blobSpaArr[k] = blobArr[i];
        superSmellsArr[i] = blobSpaArr[k];
        k++;
        blobSpaList+= str1 + " ";
        blobSpaCt+=1;
        superSmellsCt+=1;
    }
    if(lazyList.includes(str1) === true)
      {
        blobLazyArr[l] = blobArr[i];
        superSmellsArr[i] = blobLazyArr[l];
        l++;
        blobLazyList+= str1 + " ";
        blobLazyCt+=1;
        superSmellsCt+=1;
    }
  }

  superSmellsList = blobDecomList + blobSpaList + blobLazyList;
  superSmellsList = superSmellsList.split(/[ ,]+/).join(', ');
  superSmellsList = superSmellsList.replace(/,\s*$/, "");

  badCt = blobCt + decomCt + spaCt + lazyCt;

  var paths = [];
  data.forEach(function(d, i){
    paths.push(d.cname);
  });
  paths = paths.map(function(path){return path.split('.');});

  var result = stringify(structurize(paths));
  var packages = [];
  for (var i=0; i<paths.length;i++){
    if(packages.includes(paths[i][paths[i].length-2])){
    }
    else{
    packages.push(paths[i][paths[i].length-2]);
    }
  }
  numberOfPackages = packages.length;
  result = stringify(structurize(paths)).join("\n");
  // console.log(result);

}

/* ------------------------------------------------------------------------*/
/* Click and hover events */
/* ------------------------------------------------------------------------*/

// TODO: also show the metric description in the details panel
$(document).on("click", "button.collapsible", function () {
    $(this)[0].classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
        content.style.display = "none";
    } else {
        content.style.display = "block";
    }
});

//Highlighting corresponding element of vis on hovering class name in text
$(document).on("mouseover", ".className", function () {
    var className = $(this).text();
    showHoverHighlighting(className);
 }).on('mouseout', '.className', function() {
  var className = $(this).text();
    if(haveClassToPersist){
      removeHoverHighlighting(className); 
    }
    else {
      removePersistentHighlighting(className);
      removeHoverHighlighting(className); 
    }
 });

$(document).on("click", ".className", function() {
  var className = $(this).text();
  var idx = Number($(this).attr("data-index"));
  var str = fullData[idx].cname;
  var url = "sourcecode/src/" + str.replace(/[.]/g, "/") + ".java";

  updateScatterPlot($(this));
 
  updateDetailPanel("Class "+str.split(".").pop(), $('<pre id="sourcecodeContainer"><code id="sourcecode" class="language-java"></code></pre>'));
  // TODO: replace by asynchronous load
  var src = $.ajax({
    url: url,
    async: false
  }).responseText;
  src = src.substring(src.indexOf("package "));   // cut out license text
  $("#sourcecode").text(src);
  Prism.highlightElement($("#sourcecode")[0]);
  updateClassDescription(generateClassDescription(str.split('.').pop()));
  makeSelectionPersistent(className);
});


// TODO: give for each pattern an example (maybe one for high, medium and low).
// TODO: integrate links to the respective metrics
$(document).on("click", ".smellBlob", function () {
    updateDetailPanel("Background: The 'Large Class' Smell", '<p>The Large Class smell identifies those classes that contain too much functionality. Most likely, it is recommendable to split these classes into multiple ones. Exceptions might be generated code.</p>');
    
    scatterPlotDimensions =['loc', 'amc'];
    makeScatterPlot(fullData);
    
    if (blobCt > 0) {
        var newdata = [];
        fullData.forEach(function (d, i) {
            newdata.push(!!d.smells.blob);
        });
        scatterfilter(newdata);

        var dims = {};
        dims['loc'] = [1500, null];
        dims['amc'] = [129, null];

        parallelfilter(dims);

        var caption = 'The <span class="BSLegend">Classes</span> containing Large Class smell have <span class="loc">loc</span> > 1500 and <span class="amc">amc</span> > 129.';
        updateCaption(caption);
    }
});

$(document).on("click", ".smellFc", function () {
    updateDetailPanel("Background: The 'Functional Decomposition' Smell", '<p>This smell refers to classes created in a way that rather fit procedural not object-oriented programming. This means, the affected classes are mostly used a group of methods, not as a part of an object-oriented design leveraging inheritance, instantiation, and other concepts.</p>');

    scatterPlotDimensions =['npm', 'wmc'];
    makeScatterPlot(fullData);

    if (decomCt > 0) {
        var newdata = [];
        fullData.forEach(function (d, i) {
            newdata.push(!!d.smells.decomposition);
        });
        scatterfilter(newdata);

        var dims = {};
        dims['npm'] = [null, 8];
        dims['wmc'] = [16, null];
        parallelfilter(dims);

        var caption = 'The <span class="BSLegend">Classes</span> containing Functional Decomposition smell have <span class="wmc">wmc</span> > 16 and <span class="npm">npm</span> < 8';
        updateCaption(caption);
    }
});

$(document).on("click", ".smellSpa", function () {
    updateDetailPanel("Background: The 'Spaghetti Code' Smell", '<p>The metaphor of spaghetti refers to methods that are overly long. Similar to <span class="smellFc clickable">Functional Decomposition</span>, classes that are affected by this are not designed in an object-oriented, but a procedural way.</p>');
    
    // TODO: What should be the second dimension here?
    scatterPlotDimensions =['amc', 'wmc'];
    makeScatterPlot(fullData);
    
    if (spaCt > 0) {
        var newdata = [];
        fullData.forEach(function (d, i) {
            newdata.push(!!d.smells.spaghetti);
        });
        scatterfilter(newdata);

        var dims = {};
        dims['amc'] = [151, null];
        parallelfilter(dims);

        var caption = 'The <span class="BSLegend">Classes</span> containing Spaghetti Class smell have <span class="amc">amc</span> > 151';
        updateCaption(caption);
    }
});

$(document).on("click", ".smellLazy", function () {
    updateDetailPanel("Background: The 'Lazy Class' Bad Smell", '<p>A Lazy Class is the opposite of a <span class="smellBlob clickable">Large Class</span>: a class that contains almost no functionality. Often, it should be integrated with another class.</p>');
    
    // TODO: What should be the second dimension here?
    scatterPlotDimensions =['amc', 'wmc'];
    makeScatterPlot(fullData);

    if (lazyCt > 0) {
        var newdata = [];
        fullData.forEach(function (d, i) {
            newdata.push(!!d.smells.lazy);
        });
        scatterfilter(newdata);

        var dims = {};
        dims['wmc'] = [0, 0.1];
        parallelfilter(dims);

        var caption = 'The <span class="BSLegend">Classes</span> containing Lazy Class smell have <span class="wmc">wmc</span> = 0';
        updateCaption(caption);
    }
});

$(document).on("click", ".couplingMetric", function () {
    showCouplingMetricDescription();

    //TODO: can't display 3 dimension, maybe select most relevant two
    scatterPlotDimensions =['ce', 'ca'];
    makeScatterPlot(fullData);
});

$(document).on("click", ".complexityMetric", function () {
    showComplexityMetricDescription();

    scatterPlotDimensions =['max_cc', 'wmc'];
    makeScatterPlot(fullData);
});

$(document).on("click", ".cohesionMetric", function () {
    showCohesionMetricDescription();
     //TODO: can't display 1 dimension, maybe select one more relevant
    scatterPlotDimensions =['lcom3', 'dit'];
    makeScatterPlot(fullData);
});

$(document).on("click", ".inheritanceMetric", function () {
    showInheritanceMetricDescription();
    //TODO: can't display 1 dimension, maybe select one more relevant
    scatterPlotDimensions =['noc', 'dit'];
    makeScatterPlot(fullData);
});
$(document).on("click", "#closeBtn", function () {
    removePersistentHighlighting();
    updateDetailPanel('','');
});

function updateScatterPlot(clickedClass){
  // console.log(clickedClass.parent().attr('id'));
  var className = clickedClass.text();
  //Selecting relevant dimensions in scatterplot
  var cSmells = fullData[classShortNameToIndex[className]].smells;
  if (clickedClass.parent().attr('id') === "textAPanel"){
    scatterPlotDimensions=['loc','bug'];
    makeScatterPlot(fullData);
  }
  else if (cSmells.blob == true) {
      scatterPlotDimensions=['loc','amc'];
      makeScatterPlot(fullData);
  }
}

function showClassCaption(className) {
    var bs = findBadSmellsInClass(className);
    $('#captionPP').append('<span id="dynamicCaption"></span>');
    $('#dynamicCaption').append(createClassSpan(className) + ' carries ' + (bs.length === 1 ? 'a ' : '') + (bs.length > 0 ? printList(bs) : 'no') + ' code smell' + (bs.length === 1 ? '' : 's') + '.');
}
function showPersistentClassCaption(className) {
    var bs = findBadSmellsInClass(className);
    // $('#captionPP').append('<span id="dynamicPersistentCaption"></span>');
    var content = createClassSpan(className) + ' carries ' + (bs.length === 1 ? 'a ' : '') + (bs.length > 0 ? printList(bs) : 'no') + ' code smell' + (bs.length === 1 ? '' : 's') + '.';
    updateCaption(content)
}

function updateCaption(content){
  $('#adaptiveCaption').remove();
  $('#captionPP').append('<span id="adaptiveCaption"></span>');
  $('#adaptiveCaption').append(' '+ content); 
}

function highlightCodeSmell(className) {
    var cSmells = fullData[classShortNameToIndex[className]].smells;
    if (cSmells.blob == true) {
        $(".smellBlob").css('background', '#ffe68e');
    }
    if (cSmells.decomposition == true) {
        $(".smellFc").css('background', '#ffe68e');
    }
    if (cSmells.spaghetti == true) {
        $(".smellSpa").css('background', '#ffe68e');
    }
    if (cSmells.lazy == true) {
        $(".smellLazy").css('background', '#ffe68e');
    }
}

function showHoverHighlighting(className){
  $('span.className:contains("'+className+'")').css('background','#ffe68e');
  $("span.slcls." + className + "", window.parent.document).css('background', '#ffe68e');
  $("#scatterplot").contents().find("circle#" + className).attr("r", "6").attr("stroke", "#ffe68e").attr("stroke-width", "4px");

  //Highlighting edge of parallel coordinates when hovering over dot in scatter plot
  var d = window.parent.fullData;
  highlightEdge(d[classShortNameToIndex[className]]);
  highlightCodeSmell(className);
  // showClassCaption(className);
}

function makeSelectionPersistent(className){
  //Already a class selected then clear highlighting first
  removePersistentHighlighting();

  //make the highlight persistent now
  $("span.slcls."+className+"").css('background','black');
  $("#scatterplot").contents().find("circle#"+className).css("fill","black");

  // highlightEdge(fullData[classShortNameToIndex[className]]);
  makeEdgePersistent(className);

  //make code smell name persistent
  var cSmells = fullData[classShortNameToIndex[className]].smells;
  if (cSmells.blob == true){
    $(".smellBlob").css('font-weight','bold');
  }
  if (cSmells.decomposition == true){
    $(".smellFc").css('font-weight','bold');
  }
  if (cSmells.spaghetti == true){
    $(".smellSpa").css('font-weight','bold');
  }
  if (cSmells.lazy == true){
    $(".smellLazy").css('font-weight','bold');
  }

  haveClassToPersist= true;
  persistentClass = className;

}
function removePersistentHighlighting(className){
  $(".smellBlob").css('font-weight','normal');
  $(".smellFc").css('font-weight','normal');
  $(".smellSpa").css('font-weight','normal');
  $(".smellLazy").css('font-weight','normal');

  $("span.slcls").css('background',''); 
  $("#scatterplot").contents().find("circle").css('fill', '#8d8e8e');
  $("#scatterplot").contents().find("circle#"+className).attr("r","3").attr("stroke", "").attr("stroke-width","0px");
  unHighlight();
  $('.clickable').css('background','none');

  //reset to original caption
  $('#adaptiveCaption').remove();

  haveClassToPersist = false;
  persistentClass = "";
}

function removeHoverHighlighting(className){
  $("span.slcls."+className+"",window.parent.document).css('background','');
  if (persistentClass != '') $("span.slcls."+persistentClass+"",window.parent.document).css('background','black');
  
  $("#scatterplot").contents().find("circle#"+className).attr("r","3").attr("stroke", "").attr("stroke-width","0px");
  if (persistentClass != '') $("#scatterplot").contents().find("circle#"+persistentClass).css('fill', 'black');
  unHighlight();  
  $('.clickable').css('background','none');
   
  //reset to original caption
  $('#dynamicCaption').remove();
}

/* ------------------------------------------------------------------------*/
/* Util functions */ 
/* ------------------------------------------------------------------------*/

function clone(obj) {
	if (obj === null || typeof(obj) !== 'object' || 'isActiveClone' in obj)
		return obj;

	if (obj instanceof Date)
		var temp = new obj.constructor(); //or new Date(obj);
	else
		var temp = obj.constructor();

	for (var key in obj) {
		if (Object.prototype.hasOwnProperty.call(obj, key)) {
			obj['isActiveClone'] = null;
			temp[key] = clone(obj[key]);
			delete obj['isActiveClone'];
		}
  }
	return temp;
}

function findClassWithMaxValueOfMetricX (X){
  var max =  Math.max.apply(Math, fullData.map(function(o) { return o[X]; }))
  var maxClass = fullData.filter(function(d){ return d[X] == max;})[0];
  
  return maxClass.cname;
}

function createClassSpan(cname) {
  var i = classFullNameToIndex[cname]? classFullNameToIndex[cname]: classShortNameToIndex[cname]; // TODO always use full names internally
  return "<span class='className clickable' data-index='" + i + "'>" + cname.split(".").pop() + "</span>";
}

function printList(list){
    var s="";
    switch(list.length){
      case 1: s += list[0]; break;
      case 2: s +=  list[0] + " and " + list[1]; break;
      default:
        for(var i=0; i<list.length; i++){
          if (i != list.length-1){
            s += list[i]+ ", ";
          }
          else s += " and " + list[i];
        }
    }
    return s;
  }

// TODO: rename and use printList() here instead of a code clone
function printItalicList(list){
  var s="";
  switch(list.length){
    case 1: s += createClassSpan(list[0]); break;
    case 2: s += createClassSpan(list[0])+ ' and ' + createClassSpan(list[1]); break;
    default:
      for(var i=0; i<list.length; i++){
        if (i != list.length-1){
          s += createClassSpan(list[i]) + ", ";
        }
        else s += " and " + createClassSpan(list[i]);
      }
  }
  return s;
}

// TODO: use this util function consistently
function updateDetailPanel(title, content) {
  $("#detailsHeader").text(title);
  $("#detailsContent").empty();
  $("#detailsContent").append($(content));
}
//FIXME: it is not taking the style of span tags specified inside!
function updateClassDescription(content){
  $("#detailsContent").prepend('<p id="classDescription"></p>');
  $('#classDescription').html(content);
  $('#detailsHeader').prepend('<span id="closeBtn">[X] </span>');
}

function findBadSmellsInClass(className){
  //use global data variable called fullData
  var bs = [];
  if (fullData[classShortNameToIndex[className]].smells['blob']){ bs.push('Large Class')};
  if (fullData[classShortNameToIndex[className]].smells['decomposition']){ bs.push('Functional Decomposition')}; 
  if (fullData[classShortNameToIndex[className]].smells['spaghetti']){ bs.push('Spaghetti Code')}; 
  if (fullData[classShortNameToIndex[className]].smells['lazy']){ bs.push('Lazy Class')}; 

  return bs;
}

// TODO: use consistently
function createCollapsibleClassList(list) {
   return '<button class="collapsible"></button><div class="content">' + printList(list) + '</div>';
}

function structurize(paths) {
  var items = [];
  for (var i = 0, l = paths.length; i < l; i++) {
    var path = paths[i];
    var name = path[0];
    var rest = path.slice(1);
    var item = null;
    for (var j = 0, m = items.length; j < m; j++) {
      if (items[j].name === name) {
        item = items[j];
        break;
      }
    }
    if (item === null) {
      item = { name: name, children: [] };
      items.push(item);
    }
    if (rest.length > 0) {
      item.children.push(rest);
    }
  }
  for (i = 0, l = items.length; i < l; i++) {
    item = items[i];
    item.children = structurize(item.children);
  }
  return items;
}

function stringify(items) {
  var lines = [];
  for (var i = 0, l = items.length; i < l; i++) {
    var item = items[i];
    lines.push(item.name);
    var subLines = stringify(item.children);
    for (var j = 0, m = subLines.length; j < m; j++) {
      lines.push("  " + subLines[j]);
    }
  }
  return lines;
}

function noOfBadSmells(list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].badSmells.length == 4)
      return list[i];
    else if (list[i].badSmells.length == 3)
      return list[i];
    else if (list[i].badSmells.length == 2)
      return list[i];
  }
}

//bugs report
function NoOfBugSmells(list) {
  for (var i = 0; i < list.length; i++) {
    if (list[i].badSmells.length == 4 && list[i].bug != "0")
      return list[i];
    else if (list[i].badSmells.length == 3 && list[i].bug != "0")
      return list[i];
    else if (list[i].badSmells.length == 2 && list[i].bug != "0")
      return list[i];
  }
}

function classesWithBugSmells(list) {
  var c = [];
  for (var i = 0; i < list.length; i++) {
    if (list[i].badSmells.length == 4 && list[i].bug != "0")
      c.push(list[i].name);
    else if (list[i].badSmells.length == 3 && list[i].bug != "0")
      c.push(list[i].name);
    else if (list[i].badSmells.length == 2 && list[i].bug != "0")
      c.push(list[i].name);
  }
  return c;
}

function countClassesHavingBadSmells(data) {
  var count = 0;
  for (var i = 0; i < data.length; i++) {
    if (data[i].badSmells.length != 0) {
      count++;
    }
  }
  return count;
}

/* ------------------------------------------------------------------------*/
/* Parallel Coordinates */ 
/* ------------------------------------------------------------------------*/
 // load csv file and create the chart
function parallelplot(data) {
  // console.log(data);
	data.forEach(function(d, i){
		// delete d.cname;
		delete d.rfc;
		delete d.dam;
		delete d.moa;
		delete d.mfa;
		delete d.cam;
		delete d.ic;
		delete d.cbm;
		delete d.avg_cc;
	});
	// console.log(data[0]);

	//specify the dimensions and their order
	var myDimensions = {
		"wmc": {type:"number"},
		"max_cc": {type:"number"},
		"cbo":{type:"number"},
		"ca": {type:"number"},
		"ce": {type:"number"},
		"lcom3": {type:"number"},
		"noc": {type:"number"},
		"dit": {type:"number"},
		"loc": {type:"number"},
		"amc": {type:"number"},
		"npm": {type:"number"},
	};

  pcz = d3.parcoords()("#parallelplot")
    .data(data)
    .hideAxis(["name"])
    .composite("darken")
		.color(function(d) {
      return "#8d8e8e";
    })
		.hideAxis(['cname'])
		.dimensions(myDimensions)
    .render()
    .brushMode("1D-axes")  // enable brushing
    .interactive() // command line mode
    .brushedColor("black");
		
  // adding axis labels
  pcz.svg.selectAll(".dimension")
    .selectAll(".label")
		.style("font-size", "14px");

}
function unHighlight(){
	//clearing the highlighting
	pcz.unhighlight();
}
function highlightEdge(d){
  var classData = {cname:d.cname,
          amc: d.amc,
          bug: d.bug,
          ca: d.ca,
          cbo: d.cbo,
          ce: d.ce,
          dit: d.dit,
          lcom3: d.lcom3,
          loc: d.loc,
          max_cc: d.max_cc,
          noc: d.noc,
          npm: d.npm,
          wmc: d.wmc};
	pcz.highlight([classData]);
}
function makeEdgePersistent(className){
  //TODO: maybe find a better way of doing it. 
  pcz.brushReset();
  pcz.color(function(d){
    if(d.cname.split('.').pop() == className){
      return 'black';
    }
    return '#8d8e8e';
  }).render();
}

function parallelfilter(dims) {
	for(var dim in dims){
		var domain = pcz.dimensions()[dim].yscale["domain"]();

		if(dims[dim][0] == null){
			dims[dim][0] = Math.min(domain[0], domain[1]);
		}
		if(dims[dim][1] == null){
			dims[dim][1] = Math.max(domain[0], domain[1]);
		}
  }
	pcz.brushReset();
	pcz.brushExtents(dims);
}

/* ------------------------------------------------------------------------*/
/* Scatter Plot */ 
/* ------------------------------------------------------------------------*/

// TODO: Fix size and layout of scatterplot 
// TODO: Needs cleaning and refactoring 
function makeScatterPlot(data){
  
  var root = d3.select('#controls');
  var tooltip = d3.select('#tooltip').style("opacity", 0);

    var OUTLIER_THRESHOLD = 15, selectData = [], prev_data, excluded_keys = ["smells","cname", "index", "neighbors", "rfc", "dam", "moa", "mfa", "cam", "ic", "cbm", "avg_cc"], prev_options = {}, dimensions = [];
  
    prev_data = clone(data);
    
    var columns = Object.keys(data[0]);
    selectData = [];
    for(var c in columns) {
        if(excluded_keys.indexOf(columns[c]) == -1) {
            selectData.push({text: columns[c]});
        }
    }

    setup(data);

    function xChange(){
        prev_options.xSelect = this.value;
        if(prev_data) {
            var chart_data = clone(prev_data);
            xVal = this.value;
            setup(chart_data);
        }
    }

    function yChange(){
        prev_options.ySelect = this.value;
        if(prev_data) {
            var chart_data = clone(prev_data);
            yVal = this.value;
            setup(chart_data);
        }
    }

    function updateThreshold(){
        const thresh = OUTLIER_THRESHOLD;
        try {OUTLIER_THRESHOLD = parseInt(document.getElementById("outlierInput").value);} catch(e){}
        if(thresh != OUTLIER_THRESHOLD) {
            var chart_data = clone(prev_data);
            setup(chart_data);
        }
    }

    function setup(data){
        // console.log(data);
        try {OUTLIER_THRESHOLD = parseInt(document.getElementById("outlierInput").value);} catch(e){}

        d3.selectAll('#controls>*').remove();

        var xSpan = root.append('span')
            .text('X-axis: ');

        var xInput = root.append('select')
            .attr('id','xSelect')
            .on('change', xChange)
            .selectAll('option')
            .data(selectData)
            .enter()
            .append('option')
            .attr('value', function (d) { return d.text })
            .text(function (d) { return d.text ;});

        var ySpan = root.append('span')
            .text(' Y-Axis: ')

        var yInput = root.append('select')
            .attr('id','ySelect')
            .on('change',yChange)
            .selectAll('option')
            .data(selectData)
            .enter()
            .append('option')
            .attr('value', function (d) { return d.text })
            .text(function (d) { return d.text ;});

        dimensions = [];
        d3.keys(data[0]).map(function(item){
            try {if(item != "cname" && !isNaN(parseFloat(data[0][item]))) {
                dimensions.push(item);
            }} catch(e){}
        });

        if (scatterPlotDimensions.length == 0){
          // Dimensions coming from the x and y dimension selectors
          var dims = {};
          var dimension = [dimensions[0], dimensions[0]];
          try {if(prev_options.xSelect != null) {
              document.getElementById("xSelect").value = prev_options.xSelect;
              dimension[0] = prev_options.xSelect;
              dims[dimension[0]] = [null, 0];
          }} catch(e){}
          try {if(prev_options.ySelect != null) {
              document.getElementById("ySelect").value = prev_options.ySelect;
              dimension[1] = prev_options.ySelect;
              dims[dimension[1]] = [null, 0];
          }} catch(e){}
        }
        else {
          //Dimensions coming from the global variable.
          dimension = scatterPlotDimensions; 
          document.getElementById("xSelect").value = dimension[0];
          document.getElementById("ySelect").value = dimension[1];
        }
        

        d3.selectAll("#chart>*").remove();
        var h = d3.select("#chart").style("height");
        var size = +h.substring(0,h.length -2);

        var scatterplot = ScatterPlot().$el("#chart").size(size).threshold(12).margin(30).threshold(OUTLIER_THRESHOLD)
            .dotRadius(4).dotOpacity(1).dimensions(dimension).data(data).mouseover(function(d, i){
                tooltip.style("opacity", 1)
                    .html((d.cname ? d.cname.split(".").pop() : ("label" + d.index.toString())))
                    .style("left", (d3.event.pageX - 155) + "px")  // specify x location
                    .style("top", (d3.event.pageY - 110) + "px");  // specify y location
            }).mouseout(function(d){
                tooltip.style("opacity", 0);
            });
        scatterplot.render();
    }
    // Clearing the gloabl variable after scatter plot has been made
    scatterPlotDimensions.length=0;
  
}
function scatterfilter(newdata){
		var g = d3.select("#chart svg g");
		g.selectAll(".dot")
			.style("fill", function(d,i) { return newdata[i]? "black": "#8d8e8e";} );

}

</script>
</html>
