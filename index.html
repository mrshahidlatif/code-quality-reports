<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8">
    <script src="lib/jquery-2.2.2.min.js"></script>
    <script src="lib/jquery.sparkline.js"></script>
    <script type="text/javascript" src="lib/prism.js"></script>
    <script type="text/javascript" src="js/jquery.sparkline.min.js"></script>
    <script type="text/javascript" src="js/mysparklines.js"></script>
    <script type="text/javascript" src="js/dictionary.js"></script>    

    <link rel='stylesheet' href='css/mysparklines.css' type='text/css' media='all' />
    <link rel='stylesheet' href='css/main.css' type='text/css' media='all' />
    <link href="lib/prism.css" rel="stylesheet" />
  </header>

<!-- <div class="heading">
    <input id="file-upload" type="file" value="Upload" onchange="handleFileSelect(event)"/>
    <div id="title" style="margin-top:0px;">Code Quality Documents </div>
    <div id="subtitle" style="margin-top:0px;"></div>
</div> -->

<body>
  <div class="grid-container">
    <div class="header">
      <input id="file-upload" type="file" value="Upload" onchange="handleFileSelect(event)"/>
      <div id="title">Code Quality Documents </div>
      <div id="subtitle" ></div>
    </div>
    <div class="text">
      <div class="quality">
          
      </div>
      <div class="generalQuality">
          <p id="reporttext"></p>
      </div>
    </div>
    <div class="vis">
        <!-- TODO: replace iframes -->         
        <iframe id="parallelplot"></iframe>
        <iframe id="scatterplot"></iframe>
        <div id="captionPP"></div>
        <div id="captionSP"></div>
    </div>  
    <div id="details">
      <h3 id="detailsHeader"></h3>
      <div id="detailsContent"/>
    </div>
    <div class="foot">
    </div>
  </div>
</body>

<script type="text/javascript">
window._scatterplot = function(){};
window._parallelplot = function(){};
var projectName = "";
var fullData;
var badClasses;
var classFullNameToIndex = {}; // dictionary to retrieve idicies by class name efficiently
var classShortNameToIndex = {} // equivalent dictionary with short class names -- TODO: temporary solution, should be removed
function clone(obj) {
	if (obj === null || typeof(obj) !== 'object' || 'isActiveClone' in obj)
		return obj;

	if (obj instanceof Date)
		var temp = new obj.constructor(); //or new Date(obj);
	else
		var temp = obj.constructor();

	for (var key in obj) {
		if (Object.prototype.hasOwnProperty.call(obj, key)) {
			obj['isActiveClone'] = null;
			temp[key] = clone(obj[key]);
			delete obj['isActiveClone'];
		}
	}
	return temp;
}

var linkedSLopts = null;    //added
function handleFileSelect(event) {
	// Check for the various File API support.
	if (window.File && window.FileReader && window.FileList && window.Blob) {
		// Great success! All the File APIs are supported.
	} else {
		alert('The File APIs are not fully supported in this browser.');
	}

	$(".text").css({visibility: "hidden"});
	$("#scatterplot").attr("src", "");
	$("#parallelplot").attr("src", "");
  $("#scatterplot").attr("src", "scatterplot/scatterplot.html");
	$("#parallelplot").attr("src", "parallelplot/parallelplot.html");

	var f = event.target.files[0]; // FileList object
	projectName = f.name.replace('.csv','');
	var reader = new FileReader();
	reader.onload = function(event) {
		setTimeout(function(){
			window._scatterplot(event.target.result);
		}, 2000);
	};

  document.getElementById("subtitle").innerHTML = projectName;
	// Read in the file as a data URL.
	reader.readAsDataURL(f);
	//modified
	linkedSLopts = {
                  csvurl: encodeURI("csv/"+f.name),
                  slids: ['samplsl1','samplsl2', 'samplsl3', 'samplsl4'],     //pass ids for containers of first and second graph, dafaults to ['sl1', 'sl2']
                  sldef: ['cbo,ca,ce', 'wmc,max_cc', 'lcom,lcom3', 'dit,noc'], //pass fields for graphs, defaults to ['cbo,ca,ce', 'wmc,max_cc']
                  slopts: [
                            {height: 25}, //pass Sparklines options, dafaults to {type: 'bar', disableHiddenCheck: true, height: 200, barWidth: 4}
                            //pass options specfic to each sl if required, in order
                            {stackedBarColor: ['#238b45','#66c2a4','#b2e2e2']},
                            {stackedBarColor: ['#2b8cbe','#7bccc4']},
                            {stackedBarColor: ['#c51b8a','#fa9fb5']},
                            {stackedBarColor: ['#88419d','#8c96c6']},
                          ],
                  //HLclass: 'hl',                       //pass class used to high  //function to run on success, null by defaultlight linked bar, defaults to 'hl'
                  fn_wrapup: function() {   //function to run on success, null by default
                                      $(".content").hide();
                                      $(".text").css({visibility: "visible"});
                                     }
                 }
  //end of modified
}

function generateReport(){
  var data = clone(_chartdata);
  //making data available to all files
  fullData = data;
  // console.log(fullData);

	data.forEach(function(d, i){
		d.index = i;
		d.smells = {
			blob: false,
			decomposition: false,
			spaghetti: false,
      highblob : false,
      lazy: false,
		};

		var LOC = d["LOC"] || d["loc"],
			AMC = d["AMC"] || d["amc"],
			WMC = d["WMC"] || d["wmc"],
			NPM = d["NPM"] || d["npm"];

		if(LOC >= 1500 && AMC >= 129){
			d.smells.blob = true;
		}

    if(LOC >= 8000 && AMC >= 129){
			d.smells.highblob = true;
		}

		if(NPM <= 8 && WMC >= 16){
			d.smells.decomposition = true;
		}

		if(AMC >= 151){
			d.smells.spaghetti = true;
		}

    if(WMC == 0){
      d.smells.lazy = true;
    }
	});

	var $reporttext = $("#reporttext"), html = "", badCt = 0, bugCt = 0, goodCouplingCt = 0, regularCouplingCt = 0, badCouplingCt = 0, goodInheritanceCt = 0, regularInheritanceCt = 0, badInheritanceCt = 0, goodCohesionCt = 0, regularCohesionCt = 0, badCohesionCt = 0, goodComplexityCt = 0, regularComplexityCt = 0, badComplexityCt = 0, bugBlobCt = 0, bugDecomCt = 0, blobDecomCt = 0, blobSpaCt = 0, blobLazyCt = 0, superSmellsCt = 0, goodCouplingPercent = 0, regularCouplingPercent = 0, badCouplingPercent = 0, goodInheritancePercent = 0, regularInheritancePercent =0, badInheritancePercent = 0, goodCohesionPercent = 0, regularCohesionPercent = 0, badCohesionPercent = 0, goodComplexityPercent = 0, regularComplexityPercent = 0, badComplexityPercent = 0, classCt = data.length, blobCt = 0, blobList = "", bugList = "", blobArr = [], bugArr = [], goodCouplingArr = [], regularCouplingArr = [], badCouplingArr = [], goodComplexityArr = [], regularComplexityArr = [], badComplexityArr = [], goodInheritanceArr = [], regularInheritanceArr = [], badInheritanceArr = [], goodCohesionArr = [], regularCohesionArr = [], badCohesionArr = [], bugBlobArr = [], bugDecomArr = [], blobDecomArr = [], blobSpaArr = [], blobLazyArr = [], superSmellsArr = [], goodCouplingList = "", regularCouplingList = "", badCouplingList = "",  goodInheritanceList = "", regularInheritanceList = "", badInheritanceList = "", goodCohesionList = "", regularCohesionList = "",  badCohesionList = "", goodComplexityList = "", regularComplexityList = "", badComplexityList = "", bugBlobList = "", bugDecomList = "", blobDecomList = "", blobSpaList = "", blobLazyList = "", superSmellsList = "", decomCt = 0, decomList = "", decomArr = [], spaCt = 0, spaList = "", spaArr = [], highblobCt = 0, highblobList = "", highblobArr = [], lazyCt = 0, lazyList = "", lazyArr = [], blobTag = false, decomTag = false, projInfo = "", numberOfPackages = 0, classesWithBadSmells = [], bugSpaArr = [], bugLazyArr = [], bugSpaList = "", bugLazyList = "", bugSpaCt = 0, bugLazyCt = 0, spaTag = false, lazyTag = false;

	data.forEach(function(d, i){
    classFullNameToIndex[d.cname] = i; 
    classShortNameToIndex[d.cname.split(".").pop()] = i;
    var s = d.smells;
    var badClass = new Object;
    var badSmellsinClass = [];

    var bad = false;
    
    var classSpan = createClassSpan(d.cname);

    // TODO: remove code clones in the following

		if(s.blob){
			blobCt++;
      blobArr.push(classSpan);
      bad = true;

      badSmellsinClass.push("blob");
		}

    if(s.highblob){
      highblobCt++;
      highblobArr.push(classSpan);
      //bad = true;


    }

		if(s.decomposition){
      decomCt++;
      decomArr.push(classSpan);
			bad = true;
      badSmellsinClass.push("functional decomposition");
		}

		if(s.spaghetti){
      spaCt++;
      spaArr.push(classSpan);
      bad = true;

      badSmellsinClass.push("spaghetti code");
		}

    if(s.lazy){
      lazyCt++;
      lazyArr.push(classSpan);
      badSmellsinClass.push("lazy class");
    }

    if(d.bug >= 1){

      bugCt++;
      bugArr.push(classSpan);
    }

		if(bad){
			badCt++;
    }
    if (s.lazy || s.spaghetti || s.decomposition || s.blob || d.bug > 0){
      badClass.name =  d.cname.split(".").pop();
      badClass.badSmells = badSmellsinClass;
      badClass.bug = d.bug;
      classesWithBadSmells.push(badClass);
    }
    badClasses = classesWithBadSmells;
    // console.log(classesWithBadSmells);
    //check for good coupling
    if(d.cbo <= 6 && (d.ca <= 7 || d.ce <=6)){
      goodCouplingCt++;
      goodCouplingArr.push(classSpan);
    }
    //check for regular coupling
    if((d.cbo >= 7 && d.cbo < 39) && ((d.ca > 7 && d.ca <=39) || (d.ce > 6 && d.ce <=16))){
      regularCouplingCt++;
     regularCouplingArr.push(classSpan);
   }
   //check for bad coupling
   if((d.cbo >= 9) && ((d.ca > 39) || (d.ce > 16))){
     badCouplingCt++;
     badCouplingArr.push(classSpan);
    }
  //check for good inheritance
   if(d.dit <= 2 && d.noc <= 1){
     goodInheritanceCt++;
    goodInheritanceArr.push(classSpan);
   }
   //check for regular inheritance
   if((d.dit > 2 && d.dit <= 4) && (d.noc > 1 && d.noc <= 3)){
     regularInheritanceCt++;
    regularInheritanceArr.push(classSpan);
   }
   //check for bad inheritance
   if(d.dit > 4 && d.noc > 3){
     badInheritanceCt++;
    badInheritanceArr.push(classSpan);
   }
   //check for good cohesion
   if(d.lcom3 <= 0.167){
     goodCohesionCt++;
     goodCohesionArr.push(classSpan);
   }
   //check for regular cohesion
   if(d.lcom3 > 0.167 && d.lcom3 <= 0.725 ){
     regularCohesionCt++;
     regularCohesionArr.push(classSpan);
   }
   //check for bad cohesion
   if(d.lcom3 > 0.725){
     badCohesionCt++;
     badCohesionArr.push(classSpan);
   }
   //check for good Complexity
   if(d.max_cc <= 2 || d.wmc <= 11){
     goodComplexityCt++;
     goodComplexityArr.push(classSpan);
   }
   //check for regular Complexity
   if((d.max_cc > 2 && d.max_cc <= 4) || (d.wmc > 11 && d.wmc <= 34)){
     regularComplexityCt++;
     regularComplexityArr.push(classSpan);
   }
   //check for bad Complexity
   if(d.max_cc > 4 || d.wmc > 34){
     badComplexityCt++;
     badComplexityArr.push(classSpan);
   }
  })

  //classes with coupling metrics values
  goodCouplingPercent = Math.round((goodCouplingCt/classCt)*100);
  regularCouplingPercent = Math.round((regularCouplingCt/classCt)*100);
  badCouplingPercent = Math.round((badCouplingCt/classCt)*100);

 //classes with inheritance metrics values
  goodInheritancePercent = Math.round((goodInheritanceCt/classCt)*100);
  regularInheritancePercent = Math.round((regularInheritanceCt/classCt)*100);
  badInheritancePercent = Math.round((badInheritanceCt/classCt)*100);

//classes with cohesion metrics values
  goodCohesionPercent = Math.round((goodCohesionCt/classCt)*100);
  regularCohesionPercent = Math.round((regularCohesionCt/classCt)*100);
  badCohesionPercent =  Math.round((badCohesionCt/classCt)*100);


//classes with complexity metrics values
  goodComplexityPercent = Math.round((goodComplexityCt/classCt)*100);
  regularComplexityPercent = Math.round((regularComplexityCt/classCt)*100);
  badComplexityPercent = Math.round((badComplexityCt/classCt)*100);
//counting the total bad smells



  for(var i = 0; i < bugArr.length; i++){
    var b = bugArr[i];
    if(i == 0){
      bugList += b;
    }else if(i == bugArr.length-1){
      bugList += " and "+b;
    }else{
      bugList += ", "+b;
    }
  }

	for(var i = 0; i < blobArr.length; i++){
		var b = blobArr[i];
		if(i == 0){
			blobList += b;
		}else if(i == blobArr.length-1){
			blobList += " and "+b;
		}else{
			blobList += ", "+b;
		}
	}

  for(var i = 0; i < highblobArr.length; i++){
		var b = highblobArr[i];
		if(i == 0){
			highblobList += b;
		}else if(i == highblobArr.length-1){
			highblobList += " and "+b;
		}else{
			highblobList += ", "+b;
		}
	}

	for(var i = 0; i < decomArr.length; i++){
		var b = decomArr[i];
		if(i == 0){
			decomList += b;
		}else if(i == decomArr.length-1){
			decomList += " and "+b;
		}else{
			decomList += ", "+b;
		}
	}

	for(var i = 0; i < spaArr.length; i++){
		var b = spaArr[i];
		if(i == 0){
			spaList += b;
		}else if(i == spaArr.length-1){
			spaList += " and "+b;
		}else{
			spaList += ", "+b;
		}
	}

  for(var i = 0; i < lazyArr.length; i++){
		var b = lazyArr[i];
		if(i == 0){
			lazyList += b;
		}else if(i == lazyArr.length-1){
			lazyList += " and "+b;
		}else{
			lazyList += ", "+b;
		}
	}

  for(var i = 0; i < goodCouplingArr.length; i++){
    var b = goodCouplingArr[i];
    if(i == 0){
      goodCouplingList += b;
    }else if(i == goodCouplingArr.length-1){
      goodCouplingList += " and "+b;
    }else{
      goodCouplingList += ", "+b;
    }
  }


  //check for classes having both bad smells and bugs
  var m = 0, n = 0;
  for(var i = 0; i < bugArr.length; i++){
    var str1 = bugArr[i].split('<i>').pop().split('</i>')[0];
    if(blobList.includes(str1) === true)
      {
        bugBlobArr[m] = bugArr[i];
        m++;
        bugBlobList+= str1 + " ";

        bugBlobCt+=1;
        blobTag = true;
      }
    if(decomList.includes(str1) === true)
      {
        bugDecomArr[n] = bugArr[i];
        n++;
        bugDecomList+= str1 + " ";
        bugDecomCt+=1;
        decomTag = true;
      }
      if(spaList.includes(str1) === true)
      {
        bugSpaArr[m] = spaArr[i];
        m++;
        bugSpaList+= str1 + " ";

        bugSpaCt+=1;
        spaTag = true;
      }
    if(lazyList.includes(str1) === true)
      {
        bugLazyArr[n] = bugArr[i];
        n++;
        bugLazyList+= str1 + " ";
        bugLazyCt+=1;
        lazyTag = true;
      }
  }

  //check for classes having multiple bad smells
  var j = 0, k = 0, l = 0;
  for(var i = 0; i < blobArr.length; i++){
    var str1 = blobArr[i].split('<i>').pop().split('</i>')[0];
    if(decomList.includes(str1) === true)
      {
        blobDecomArr[j] = blobArr[i];
        superSmellsArr[i] = blobDecomArr[j];
        j++;
        blobDecomList+= str1 + " ";
        blobDecomCt+=1;
        superSmellsCt+=1;
    }
    if(spaList.includes(str1) === true)
      {
        blobSpaArr[k] = blobArr[i];
        superSmellsArr[i] = blobSpaArr[k];
        k++;
        blobSpaList+= str1 + " ";
        blobSpaCt+=1;
        superSmellsCt+=1;
    }
    if(lazyList.includes(str1) === true)
      {
        blobLazyArr[l] = blobArr[i];
        superSmellsArr[i] = blobLazyArr[l];
        l++;
        blobLazyList+= str1 + " ";
        blobLazyCt+=1;
        superSmellsCt+=1;
    }
  }

  superSmellsList = blobDecomList + blobSpaList + blobLazyList;
  superSmellsList = superSmellsList.split(/[ ,]+/).join(', ');
  superSmellsList = superSmellsList.replace(/,\s*$/, "");

  badCt = blobCt + decomCt + spaCt + lazyCt;

  var paths = [];
  data.forEach(function(d, i){
    paths.push(d.cname);
  });
  paths = paths.map(function(path){return path.split('.');});

  var result = stringify(structurize(paths));
  var packages = [];
  for (var i=0; i<paths.length;i++){
    if(packages.includes(paths[i][paths[i].length-2])){
    }
    else{
    packages.push(paths[i][paths[i].length-2]);
    }
  }
  numberOfPackages = packages.length;
  result = stringify(structurize(paths)).join("\n");
  // console.log(result);

  //Generate report text
  $(".quality").html(badSmellsText());

  $("#subtitle").html(introText());
  html += generalQualtiyText();
  html += bugText();
  $("#captionPP").html(generatePPCaption());
  $("#captionSP").html(generateSPCaption());
  

  function introText(){
    var text = "";
    if(projectName.includes("xerces")) {
    projInfo = "A collection of software libraries for parsing, validating, serializing, and manipulating XML";
    }

    if(projectName.includes("log4j")) {
    projInfo =  "An open source project that allows the developer to control which log statements are output with arbitrary granularity.";
    }
    text += ' This document presents the code quality aspects of '+ projectName +'<span class="infoIcon" title= PROJINFO > &#9432;</span> (Java version)&mdash;it has '+ numberOfPackages + ' packages and '+classCt+' classes.';
    return text;
  }

  //general quality report

  function generateCouplingText(){
    var text = '<p>';
    var coup = '<h4><span id="couplingLegend" class="couplingMetric clickable">Coupling</span>:</h4>';
    // coupling quality
    var couplingArr = [goodCouplingPercent, regularCouplingPercent, badCouplingPercent];
    var m = Math.max(...couplingArr);
    var i  = couplingArr.indexOf(m);

    if(i == 0){
      text+= coup + ' The quality in terms of coupling is high because GOODCOUPLINGCT classes <span class="bar_5" style="vertical-align: middle;"></span> have coupling metrics in a good range. <button class="collapsible"></button><div class="content"><div id="samplsl1"></div></div>';
    }

    else if(i == 1){
      text+= coup + ' The quality in terms of coupling is moderate because REGULARCOUPLINGCT classes <span class="bar_6" style="vertical-align: middle;">have coupling metrics in an acceptable range. <button class="collapsible"></button><div class="content"><div id="samplsl1"></div></div>'
    }

    else if(i == 2){
      text+= coup + ' The quality in terms of coupling is low because BADCOUPLINGCT classes <span class="bar_7" style="vertical-align: middle;"></span> have coupling metrics in an undersired range. <button class="collapsible"></button><div class="content"><div id="samplsl1"></div></div>'
    }
    text += '</p>';
    return text;

  }
  function generateComplexityText(){
    var comp = '<h4><span id="complexityLegend" class="complexityMetric clickable">Complexity</span>:</h4>';
    // complextiy quality
    var complexityArr = [goodComplexityPercent, regularComplexityPercent, badComplexityPercent];
    m = Math.max(...complexityArr);
    i  = complexityArr.indexOf(m);
    var text = '<p>';
    if(i == 0){
      text+= comp + ' The quality from complexity perspective is high because GOODCOMPLEXITYCT classes <span class="bar_14" style="vertical-align: middle;"></span> have low complexity. <button class="collapsible"></button><div class="content"><div id="samplsl2"></div></div>'
    }
    else if(i == 1){
      text+= comp + ' The quality from complexity perspective is medium because REGULARCOMPLEXITYCT classes <span class="bar_15" style="vertical-align: middle;"></span> have regular complexity. <button class="collapsible"></button><div class="content"><div id="samplsl2"></div></div>'
    }
    else if(i == 2){
      text+= comp + ' The quality from complexity perspective is low because BADCOMPLEXITYCT classes <span class="bar_16" style="vertical-align: middle;"></span> have  high complexity. <button class="collapsible"></button><div class="content"><div id="samplsl2"></div></div>'
    }
    return text += '</p>';

  }
  function generateCohesionText(){
    var coh = '<h4><span id="cohesionLegend" class="cohesionMetric clickable">Cohesion</span>:</h4>';

    var cohesionArr = [goodCohesionPercent, regularCohesionPercent, badCohesionPercent];
    m = Math.max(...cohesionArr);
    i  = cohesionArr.indexOf(m);
    var text = '<p>';
    if(i == 0){
      text+= coh + ' High values of cohesion metrics in GOODCOHESIONCT classes <span class="bar_11" style="vertical-align: middle;"></span> reflect good project quality. <button class="collapsible"></button><div class="content"><div id="samplsl3"></div></div>'
    }
    else if(i == 1){
      text+= coh + ' Moderate values of cohesion metrics in REGULARCOHESIONCT classes <span class="bar_12" style="vertical-align: middle;"></span> reflect regular quality. <button class="collapsible"></button><div class="content"><div id="samplsl3"></div></div>'
    }
    else if(i == 2){
      text+= coh + ' Low values of cohesion metrics in BADCOHESIONCT classes <span class="bar_13" style="vertical-align: middle;"></span> reflect bad proejct quality. <button class="collapsible"></button><div class="content"><div id="samplsl3"></div></div>'
    }

    return  text += '<p>';

  }
  function generateInheritanceText(){

    var inher = '<h4><span id="inheritanceLegend" class="inheritanceMetric clickable">Inheritance</span>:</h4>';
     // inheritance quality
    var inheritanceArr = [goodInheritancePercent, regularInheritancePercent, badInheritancePercent];
    m = Math.max(...inheritanceArr);
    i  = inheritanceArr.indexOf(m);
    var text='<p>';
    if(i == 0){
      text += inher + ' Inheritance metrics indicate high quality in GOODINHERITANCECT classes <span class="bar_8" style="vertical-align: middle;"></span>. <button class="collapsible" ></button><div class="content"><div id="samplsl4"></div></div>'
    }
    else if(i == 1){
      text += inher + ' Inheritance metrics indicate acceptable quality in REGULARINHERITANCECT classes <span class="bar_9" style="vertical-align: middle;"></span>. <button class="collapsible"></button><div class="content"><div id="samplsl4"></div></div>'
    }
    else if(i == 2){
      text += inher + ' Inheritance metrics indicate low quality in BADINHERITANCECT classes <span class="bar_10" style="vertical-align: middle;"></span>. <button class="collapsible"></button><div class="content"><div id="samplsl4"></div></div>'
    }

    return text += '</p>';

  }
  function generalQualtiyText(){
    var text = '';
    // TODO: expand details (bar chart) when clicking on the metrics
  
    text+='<p><h3 align="left">General Quality Attributes:</h3> The quality of the project is described in terms of four quality attributes.'
      
    text += generateComplexityText();
    text += generateCouplingText();
    text += generateCohesionText();
    text += generateInheritanceText();
 
    return text;
  }

  function noOfBadSmells(list){
    for(var i=0;i<list.length;i++){
      if(list[i].badSmells.length == 4)
        return list[i];
    else if (list[i].badSmells.length == 3)
      return list[i];
    else if (list[i].badSmells.length == 2)
      return list[i];
    }
  }
  function badSmellsText(){
    var text = "";
    //bad smells report
    text += '<h3 align="left">Bad Smells:</h3>';
    if(badCt == 0){text+= 'There are no bad smells in the project&mdash;the quality is high and no refactoring is required.'
    }
    if(badCt == 1){	text += ' The project has '+ num2word(badCt) +' bad smell: ';
    }
    if(badCt > 1){	text += ' The project has '+ num2word(badCt) + ' bad smells: ';
    }
    var listOfBadSmellTypes=[];
    if(blobCt == 1){
      var blobText = num2word(blobCt) +' <span class="badBlob clickable"> blob</span> <span class="bar_1" style="vertical-align: middle;"></span>';
      blobText += ' <button class="collapsible"></button><div class="content"><p>' + printList(blobArr) + '</p></div>';
      listOfBadSmellTypes.push(blobText);
    }
    if(blobCt > 1){
      var blobText = num2word(blobCt) +' <span class="badBlob clickable"> blob</span> <span class="bar_1" style="vertical-align: middle;"></span>';
      blobText+= ' <button class="collapsible"></button><div class="content"><p>' + printList(blobArr) + '</p></div>';
      listOfBadSmellTypes.push(blobText);
    }
    if(decomCt == 1){
      var decomText = num2word(decomCt) + ' <span class="badFc clickable"> functional decomposition</span> <span class="bar_2" style="vertical-align: middle;"></span> <button class="collapsible"></button><div class="content"><p>' + printList(decomArr) + '</p></div>';
      listOfBadSmellTypes.push(decomText);
    }
    if(decomCt > 1){
      var decomText = num2word(decomCt) + ' <span class="badFc clickable"> functional decomposition</span> <span class="bar_2" style="vertical-align: middle;"></span> <button class="collapsible"></button><div class="content"><p>' + printList(decomArr) + '</p></div>'
      listOfBadSmellTypes.push(decomText);
    }
    if(spaCt == 1){
      var spaText = num2word(spaCt) + ' <span class="badSc clickable"> spaghetti code</span> <span class="bar_3" style="vertical-align: middle;"></span> <button class="collapsible"></button><div class="content"><p>' + printList(spaArr) + '</p></div>'
      listOfBadSmellTypes.push(spaText);
    }
    if(spaCt > 1){
      var spaText = num2word(spaCt) + ' <span class="badSc clickable"> spaghetti code</span> <span class="bar_3" style="vertical-align: middle;"></span> <button class="collapsible"></button><div class="content"><p>' + printList(spaArr) + '</p></div>';
      listOfBadSmellTypes.push(spaText);
    }
    if(lazyCt == 1){
      var lazyText = num2word(lazyCt) + ' <span class="badLazy clickable"> lazy class</span> <span class="bar_4" style="vertical-align: middle;"></span> bad smells <button class="collapsible"></button><div class="content"><p>' + printList(lazyArr) + '</p></div>';
      listOfBadSmellTypes.push(lazyText);
    }
    if(lazyCt > 1){
      var lazyText = num2word(lazyCt) + ' <span class="badLazy clickable"> lazy class</span> <span class="bar_4" style="vertical-align: middle;"></span> bad smells <button class="collapsible"></button><div class="content"><p>' + printList(lazyArr) + '</p></div>';
      listOfBadSmellTypes.push(lazyText);
    }
    text += ' ' + printList(listOfBadSmellTypes) + '.';
    if(superSmellsCt > 0){
      text+= ' Some classes <button class="collapsible"></button><div class="content"><p>' + printList(superSmellsArr) + ' .</p></div> have multiple bad smells.'
    }
    var c = noOfBadSmells(classesWithBadSmells);
    if (c != undefined){ 
      text += ' For instance, '+createClassSpan(c.name)+' has ' + num2word(c.badSmells.length) + ' bad smells: ' + printList(c.badSmells) + '.'; 
    }
    // TODO: implement the following correctly
    /* if(highblobCt == 1){
      text += ' Comparatively high metric value of lines of code indicates worse quality in <span class="className clickable">HIGHBLOB</span>.';
    }
    if(highblobCt > 1){
      text += ' Comparatively high metric value of lines of code indicates worse quality in <span class="className clickable">HIGHBLOB</span>.'
    } */
    //  html+= '<br><br>The BLOBCT blob bad smells are present in BLOBLIST. Based on high metrics values we found few blobs to be more quality deterrent. For instance, HIGHBLOB has high metrics values and probability of quality degradation could be significant in it.<br><br>The DECOMCT functional decomposition bad smells are present in DECOMLIST.<br><br>The SPACT spaghetti code bad smells are present in SPALIST.<br><br>The LAZYCT lazy class bad smells are present in LAZYLIST.'
    return text;
  }

function countClassesHavingBadSmells (data){
  var count = 0;
  for (var i=0;i<data.length;i++){
    if (data[i].badSmells.length != 0){
        count++;
    }
  }
  return count;
}

function generatePPCaption(){
  // TODO: "id" used instead of "class"
  // TODO: make metrics categories clickable
  // TODO: color metric names
  var caption = 'The overview of the software quality in terms of <span id="complexityLegend">complexity</span> (wmc, max_cc), <span id="couplingLegend">coupling</span> (cbo, ca, ce), <span id="cohesionLegend">cohesion</span> (lcom, lcom3), and <span id="couplingLegend">inheritance</span> (noc, dit).'
  caption += ' The ' + num2word(countClassesHavingBadSmells(classesWithBadSmells)) +' <span class="NoBSCap">Classes</span> contain bad smells.';

  caption += '.';

  return caption;
}
function generateSPCaption(){
 

  return 'Correlation between X and Y';
}

//bugs report
function NoOfBugSmells(list){
    for(var i=0; i<list.length; i++){
      if(list[i].badSmells.length == 4 && list[i].bug != "0")
        return list[i];
    else if (list[i].badSmells.length == 3 && list[i].bug != "0")
      return list[i];
    else if (list[i].badSmells.length == 2 && list[i].bug != "0")
      return list[i];
    }
  }

  function classesWithBugSmells(list){
    var c = [];
    for(var i=0; i<list.length; i++){
      if(list[i].badSmells.length == 4 && list[i].bug != "0")
        c.push(list[i].name);
    else if (list[i].badSmells.length == 3 && list[i].bug != "0")
      c.push(list[i].name);
    else if (list[i].badSmells.length == 2 && list[i].bug != "0")
      c.push(list[i].name);
    }
    return c;
  }


function bugText(){
  var text = "";
  text += '<h3 align="left">Bugs:</h3>'
  if(bugCt/classCt == 0){
    text =+ 'None of the classes has bugs.'
  }
  else{
    var c = NoOfBugSmells(classesWithBadSmells);
    var d = classesWithBugSmells(classesWithBadSmells);
    text+= 'Almost ' + num2word(Math.round((bugCt/classCt)*100)) + ' percent <span class="bar_17" style="vertical-align: middle;"></span> classes contain bugs.';
    if(d.length > 3){
      text += ' The classes <button class="collapsible"></button><div class="content"><p>' + printList(d) + '</p></div> carry both bugs and bad smells';
    }
    else if (d.length > 0){
      text += (d.length == 1) ? ' The class ' + printItalicList(d) + ' carries' : ' The classes ' + printItalicList(d) + ' carry' ;
      text += ' both bugs and bad smells.';
    }

  }

  return text;
}



  // if((bugCt/classCt) >= 0.15){
  //   html+= ' Most of the classes in <i>PROJECTNAME</i> carry a large number of bugs. We found BUGCT classes <button class="collapsible" onClick="expandContent()"></button><div class="content"><p>' + printList(bugArr) + '.</p></div> having large number of bugs.'
  // }
  // if((bugCt/classCt) >= 0.08 && (bugCt/classCt) <= 0.14){
  //   html+= ' Most of the classes in <i>PROJECTNAME</i> carry a reasonable number of bugs. We found BUGCT classes <button class="collapsible" onClick="expandContent()"></button><div class="content"><p>' + printList(bugArr) + '.</p></div> having large number of bugs.'
  // }
  // if((bugCt/classCt) <= 0.07 && bugCt !== 1){
  //   html+= ' Most of the classes in <i>PROJECTNAME</i> do not have a large number of bugs. We found only BUGCT classes <button class="collapsible" onClick="expandContent()"></button><div class="content"><p>' + printList(bugArr) + '.</p></div> with comparatively large number of bugs.'
  // }
  // if((bugCt/classCt) <= 0.07 && bugCt === 1){
  //   html+= ' Most of the classes in <i>PROJECTNAME</i> do not have a large number of bugs. We found only BUGCT class <button class="collapsible" onClick="expandContent()"></button><div class="content"><p>' + printList(bugArr) + '.</p></div> with comparatively large number of bugs.'
  // }

  // if(bugBlobCt === 1){
  //   if(blobTag === true && decomTag === true){
  //     html+= ' We observe that '+ BBLIST +'carries blob, functional decomposition, and bugs.'
  //   }
  //   if(blobTag === true && decomTag !== true){
  //     html+= ' We observe that BBLIST carries both blob and bugs.'
  //   }
  // }
  // if(bugBlobCt > 1){
  //   if(blobTag === true && decomTag === true){
  //     html+= ' We observe that BBLIST carry blob, functional decomposition, and bugs.'
  //   }
  //   if(blobTag === true && decomTag !== true){
  //     html+= ' We observe that BBLIST carry both blob and bugs.'
  //   }
  // }


  //visualizations
  // html += '<br><br>The sparklines below are created using values of the metrics respective to these four quality attributes. To add meaningful interpretation, the stacked-bar charts are structured with respect to packages. In addition, a parallel coordinates plot is provided to obtain the overview of the software metrics and explore correlations among them. It is also used for highlighting metrics related to bad smells.'
  //<br><span class="bad_1">Blob</span> | <span class="bad_2">Functional Decomposition</span> | <span class="bad_3">Spaghetti Code</span> | <span class="bad_4">Lazy Class</span>'



	html = html.replace(/PROJECTNAME/g, ""+projectName).replace(/ClASSCT/g, ""+classCt).replace(/BADCT/g, ""+badCt).replace(/BUGCT/g, ""+bugCt).replace(/BLOBCT/g, ""+blobCt).replace(/DECOMCT/g, ""+decomCt).replace(/SPACT/g, ""+spaCt).replace(/BLOBLIST/g, ""+blobList).replace(/LAZYCT/g, ""+lazyCt);
  html = html.replace(/DECOMLIST/g, ""+decomList).replace(/SPALIST/g, ""+spaList).replace(/HIGHBLOB/g, ""+highblobList).replace(/LAZYLIST/g, ""+lazyList).replace(/BUGLIST/g, ""+bugList);
  html = html.replace(/GOODCOUPLINGLIST/g, ""+goodCouplingList).replace(/GOODCOUPLINGCT/g, ""+goodCouplingCt).replace(/GOODCOUPLINGPT/g, ""+goodCouplingPercent).replace(/REGULARCOUPLINGLIST/g, ""+regularCouplingList).replace(/REGULARCOUPLINGCT/g, ""+regularCouplingCt).replace(/REGULARCOUPLINGPT/g, ""+regularCouplingPercent).replace(/BADCOUPLINGLIST/g, ""+badCouplingList).replace(/BADCOUPLINGCT/g, ""+badCouplingCt).replace(/BADCOUPLINGPT/g, ""+badCouplingPercent);
  html = html.replace(/GOODINHERITANCELIST/g, ""+goodInheritanceList).replace(/GOODINHERITANCECT/g, ""+goodInheritanceCt).replace(/REGULARINHERITANCELIST/g, ""+regularInheritanceList).replace(/REGULARINHERITANCECT/g, ""+regularInheritanceCt).replace(/BADINHERITANCELIST/g, ""+badInheritanceList).replace(/BADINHERITANCECT/g, ""+badInheritanceCt);
  html = html.replace(/BADCOHESIONLIST/g, ""+badCohesionList).replace(/BADCOHESIONCT/g, ""+badCohesionCt).replace(/REGULARCOHESIONLIST/g, ""+regularCohesionList).replace(/REGULARCOHESIONCT/g, ""+regularCohesionCt).replace(/GOODCOHESIONLIST/g, ""+goodCohesionList).replace(/GOODCOHESIONCT/g, ""+goodCohesionCt);
  html = html.replace(/GOODCOMPLEXITYLIST/g, ""+goodComplexityList).replace(/GOODCOMPLEXITYCT/g, ""+goodComplexityCt).replace(/REGULARCOMPLEXITYLIST/g, ""+regularComplexityList).replace(/REGULARCOMPLEXITYCT/g, ""+regularComplexityCt).replace(/BADCOMPLEXITYLIST/g, ""+badComplexityList).replace(/BADCOMPLEXITYCT/g, ""+badComplexityCt);
  html = html.replace(/BBLIST/g, ""+bugBlobArr[0]).replace(/BDLIST/g, ""+bugDecomList).replace(/BLOBDECOMSMELLSLIST/g, ""+blobDecomArr[0]).replace(/BLOBSPASMELLSLIST/g, ""+blobSpaArr[0]).replace(/BLOBLAZYSMELLSLIST/g, ""+blobLazyArr[0]);
  html = html.replace(/SUPERSMELLSLIST/g, ""+superSmellsList)
   html = html.replace(/PROJINFO/g,""+projInfo).replace(/NUMBEROFPACKAGES/g, ""+numberOfPackages);

	$reporttext.html(html);

	$(".className").click(function(){
		var idx = Number($(this).attr("data-index"));
		var str = data[idx].cname;
		var url = "sourcecode/src/" + str.replace(/[.]/g, "/") + ".java";
    $("#detailsHeader").text("File "+str.split(".").pop()+ ".java");
    $("#detailsContent").empty();
    $("#detailsContent").append($('<pre id="sourcecodeContainer"><code id="sourcecode" class="language-java"></code></pre>'));
    // TODO: replace by asynchronous load
    var src = $.ajax({
      url: url,
      async: false
    }).responseText;
    src = src.substring(src.indexOf("package "));   // cut out license text
    $("#sourcecode").text(src);
    Prism.highlightElement($("#sourcecode")[0]);
	});

  /* TODO: reimplement a proper package details page
  $(".pack").click(function(){
    var idx = Number($(this).attr("data-index"));
		var str = data[idx].cname;
    var classUrl = str.replace(/[.]/g, "/");
    var n = classUrl.search(str.split(".").pop());
    var curl = classUrl.substring(0,n);
	//	var url = "http://svn.apache.org/viewvc/xerces/java/branches/xerces_j_1/src/"+curl;
    var url = "https://svn.apache.org/repos/asf/xerces/java/branches/xerces_j_1/src/"+curl;
    $("#detailsHeader").text("Package "+url);
    $("#detailsContent").empty();
    $("#detailsContent").load(curl, function() {
    });   
	});*/

  var sparklineOptions = {
    type:'bar',
    width: '30px',
    height: '30px',
    highlightLighten: 1.1,
    highlightColor: 'black',
  }


  //bad smells charts
	drawBarChart(".bar_1", Math.round((blobCt/badCt)*1000)/10);
	drawBarChart(".bar_2", Math.round((decomCt/badCt)*1000)/10);
	drawBarChart(".bar_3", Math.round((spaCt/badCt)*1000)/10);
  drawBarChart(".bar_4", Math.round((lazyCt/badCt)*1000)/10);
  // coupling charts
  drawBarChart(".bar_5", Math.round((goodCouplingCt/classCt)*1000)/10);
  drawBarChart(".bar_6", Math.round((regularCouplingCt/classCt)*1000)/10);
  drawBarChart(".bar_7", Math.round((badCouplingCt/classCt)*1000)/10);
  //Inheritance charts
  drawBarChart(".bar_8", Math.round((goodInheritanceCt/classCt)*1000)/10);
  drawBarChart(".bar_9", Math.round((regularInheritanceCt/classCt)*1000)/10);
  drawBarChart(".bar_10", Math.round((badInheritanceCt/classCt)*1000)/10);
  // Cohesion charts
  drawBarChart(".bar_11", Math.round((goodCohesionCt/classCt)*1000)/10);
  drawBarChart(".bar_12", Math.round((regularCohesionCt/classCt)*1000)/10);
  drawBarChart(".bar_13", Math.round((badCohesionCt/classCt)*1000)/10);
  // Complexity charts
  drawBarChart(".bar_14", Math.round((goodComplexityCt/classCt)*1000)/10);
  drawBarChart(".bar_15", Math.round((regularComplexityCt/classCt)*1000)/10);
  drawBarChart(".bar_16", Math.round((badComplexityCt/classCt)*1000)/10);

  //bug chart
  drawBarChart(".bar_17", Math.round((bugCt/classCt)*1000)/10);

	window._parallelplot(clone(_chartdata));

	//columns
	var columns = data.columns;

	var LOC_S = (columns.indexOf("LOC") >= 0)? "LOC" : "loc",
		AMC_S = (columns.indexOf("AMC") >= 0)? "AMC" : "amc",
		WMC_S = (columns.indexOf("WMC") >= 0)? "WMC" : "wmc",
    NPM_S = (columns.indexOf("NPM") >= 0)? "NPM" : "npm";
    
  // FIXME: highlight of the bad smells in the PCP doesn't work anymore properly

	$(".badBlob").on("click", function(){
    var url = "bad_smell_descriptions/blob.htm";
    $("#detailsHeader").text("The 'Blob' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(blobCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.blob);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[LOC_S] = [1500, null];
			dims[AMC_S] = [129, null];

      window._parallelfilter(dims);
		}
	});

	$(".badFc").on("click", function(){
    var url = "bad_smell_descriptions/fd.htm";
    $("#detailsHeader").text("The 'Functional Decomposition' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(decomCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.decomposition);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[NPM_S] = [null, 8];
			dims[WMC_S] = [16, null];
			window._parallelfilter(dims);
		}
	});

	$(".badSc").on("click", function(){
    var url = "bad_smell_descriptions/sc.htm";
    $("#detailsHeader").text("The 'Spaghetti Code' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(spaCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.spaghetti);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[AMC_S] = [151, null];
			window._parallelfilter(dims);
		}
	});

  $(".badLazy").on("click", function(){
    var url = "bad_smell_descriptions/lazy.htm";
    $("#detailsHeader").text("The 'Lazy Class' Bad Smell");
    $("#detailsContent").empty();
    $("#detailsContent").load(url);
		if(lazyCt > 0){
			var newdata = [];
			data.forEach(function(d, i){
				newdata.push(!!d.smells.lazy);
			});
			window._scatterfilter(newdata);

			var dims = {};
			dims[WMC_S] = [0, 0.1];
			window._parallelfilter(dims);
		}
	});

  $(".couplingMetric").on("click", function(){
    showCouplingMetricDescription();
  });

  $(".complexityMetric").on("click", function(){
    showComplexityMetricDescription();
  });

  $(".cohesionMetric").on("click", function(){
    showCohesionMetricDescription();
  });

  $(".inheritanceMetric").on("click", function(){
    showInheritanceMetricDescription();
  });

  if(linkedSLopts != null) $(document).linkedSparklines(linkedSLopts);  //added

}

function structurize(paths) {
      var items = [];
      for(var i = 0, l = paths.length; i < l; i++) {
          var path = paths[i];
          var name = path[0];
          var rest = path.slice(1);
          var item = null;
          for(var j = 0, m = items.length; j < m; j++) {
              if(items[j].name === name) {
                  item = items[j];
                  break;
              }
          }
          if(item === null) {
              item = {name: name, children: []};
              items.push(item);
          }
          if(rest.length > 0) {
              item.children.push(rest);
          }
      }
      for(i = 0, l = items.length; i < l; i++) {
          item = items[i];
          item.children = structurize(item.children);
      }
      return items;
  }

  function stringify(items) {
      var lines = [];
      for(var i = 0, l = items.length; i < l; i++) {
          var item = items[i];
          lines.push(item.name);
          var subLines = stringify(item.children);
          for(var j = 0, m = subLines.length; j < m; j++) {
              lines.push("  " + subLines[j]);
          }
      }
      return lines;
  }

function drawBarChart(tagNmae, val){
	$(tagNmae).html('<svg width="50" height="14" style="background: #ccc;"><g transform="translate(0,0)" style="text-anchor: middle;"><rect class="bar" width="'+(val/2)+'" height="14"></rect><text x="25" y="11" style="font-size:12px">'+val+'%</text></g></svg>');
}

// TODO: also show the metric description in the details panel
$(document).on("click","button.collapsible", function () {
   $(this)[0].classList.toggle("active");
   var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
});

/* ------------------------------------------------------------------------*/
/* Metric descriptions */
/* ------------------------------------------------------------------------*/

// TODO: color metric names accordingly

function showCouplingMetricDescription() {
  const content = `
    <p>The metrics coupling between objects (<span id="cboCap">cbo</span>), afferent coupling (<span id="acCap">ac</span>), and efferent coupling (<span id="ecCap">ec</span>) are used to assess quality in terms of coupling. We use thresholds of the metrics to classify the individual classes as having good, regular, or bad coupling.</p>
  `;
  updateDetailPanel("Coupling", content);
}

function showComplexityMetricDescription() {
  const content = `
    <p>The metrics weighted method per class (wmc) and cyclomatic complexity (cc) contribute towards the code complexity of a class.</p>
  `;
  updateDetailPanel("Complexity", content);
}

function showCohesionMetricDescription() {
  const content = `
    <p>Two versions of lack of cohesion metric, i.e., loc and loc3 show the quality in terms of cohesion.</p>
  `;
  updateDetailPanel("Cohesion", content);
}

function showInheritanceMetricDescription() {
  const content = `
    <p>The metrics depth of inheritance (dit) and number of children (noc) are used to assess the quality in terms of inheritance.</p>
  `;
  updateDetailPanel("Cohesion", content);
}

// TODO: replace linear search
// TODO: move elsewhere
//Highlighting corresponding element of vis on hovering class name in text
$(document).on("mouseover", ".className", function() {
    var className = $(this).text();
    $("span.slcls."+className+"",window.parent.document).css('background','#ffe68e');
    $("#scatterplot").contents().find("circle#"+className).attr("r","6").attr("stroke", "#ffe68e").attr("stroke-width","4px");

    //Highlighting edge of parallel coordinates when hovering over dot in scatter plot
    var d = window.parent.fullData;
            for(var i=0; i<d.length;i++){
                if(d[i] != undefined && d[i].cname.includes(className)){
                    // console.log(d[i]);
                    window.parent._highlightEdge(d[i]);
                }
            }

 }).on('mouseout', '.className', function() {
    $("span.slcls",window.parent.document).css('background','transparent'); 
    $("#scatterplot").contents().find("circle").attr("r","3").attr("stroke", "transparent").attr("stroke-width","0px");
    window.parent._unHighlight();

 });

/* ------------------------------------------------------------------------*/
/* Util functions */ 
/* ------------------------------------------------------------------------*/

function createClassSpan(cname) {
  var i = classFullNameToIndex[cname]? classFullNameToIndex[cname]: classShortNameToIndex[cname]; // TODO always use full names internally
  return "<span class='className clickable' data-index='" + i + "'>" + cname.split(".").pop() + "</span>";
}

function printList(list){
    var s="";
    switch(list.length){
      case 1: s += list[0]; break;
      case 2: s +=  list[0] + " and " + list[1]; break;
      default:
        for(var i=0; i<list.length; i++){
          if (i != list.length-1){
            s += list[i]+ ", ";
          }
          else s += " and " + list[i];
        }
    }
    return s;
  }

  // TODO: rename and use printList() here instead of a code clone
  function printItalicList(list){
    var s="";
    switch(list.length){
      case 1: s += createClassSpan(list[0]); break;
      case 2: s += createClassSpan(list[0])+ ' and ' + createClassSpan(list[1]); break;
      default:
        for(var i=0; i<list.length; i++){
          if (i != list.length-1){
            s += createClassSpan(list[i]) + ", ";
          }
          else s += " and " + createClassSpan(list[i]);
        }
    }
    return s;
  }

// TODO: use this util function consistently
function updateDetailPanel(title, content) {
  $("#detailsHeader").text(title);
  $("#detailsContent").empty();
  $("#detailsContent").append($(content));
}

function num2word(n){
  if (numToWord[n] != undefined){
    return numToWord[n];
  }
  else return n;
}

</script>
</html>
